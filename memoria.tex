%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Plantilla de memoria en LaTeX para la ETSIT - Universidad Rey Juan Carlos
%%
%% Por Gregorio Robles <grex arroba gsyc.urjc.es>
%%     Grupo de Sistemas y Comunicaciones
%%     Escuela Técnica Superior de Ingenieros de Telecomunicación
%%     Universidad Rey Juan Carlos
%% (muchas ideas tomadas de Internet, colegas del GSyC, antiguos alumnos...
%%  etc. Muchas gracias a todos)
%%
%% La última versión de esta plantilla está siempre disponible en:
%%     https://github.com/gregoriorobles/plantilla-memoria
%%
%% Para obtener PDF, ejecuta en la shell:
%%   make
%% (las imágenes deben ir en PNG o JPG)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[a4paper, 12pt]{book}
%\usepackage[T1]{fontenc}

\usepackage[a4paper, left=2.5cm, right=2.5cm, top=3cm, bottom=3cm]{geometry}
\usepackage{times}
\usepackage[utf8]{inputenc}
\usepackage[spanish,es-tabla]{babel} % Comenta esta línea si tu memoria es en inglés
\usepackage{url}
%\usepackage[dvipdfm]{graphicx}
\usepackage{graphicx}
\usepackage{float}  %% H para posicionar figuras
\usepackage{xurl}
\usepackage[breaklinks]{hyperref}
%\usepackage[breaklinks=true, hidelinks, colorlinks]{hyperref}
\usepackage[nottoc, notlot, notlof, notindex]{tocbibind} %% Opciones de índice
\usepackage{latexsym}  %% Logo LaTeX
\usepackage{amsmath, amsthm}
\usepackage{caption}
\usepackage{subcaption}
%\usepackage{subfig}
\usepackage[table]{xcolor}
\usepackage{multirow}



\title{Memoria del Proyecto}
\author{Rosa Cristina Ruiz Rivas}

\renewcommand{\baselinestretch}{1.5}  %% Interlineado

\begin{document}

\renewcommand{\refname}{Bibliografía}  %% Renombrando
\renewcommand{\appendixname}{Apéndice}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PORTADA

\begin{titlepage}
\begin{center}
\includegraphics[scale=0.8]{img/URJ_logo_Color_POS.png}

\vspace{1.75cm}

\Large
DOBLE GRADO EN INGENIERÍA EN SISTEMAS DE TELECOMUNICACIÓN Y ADMINISTRACIÓN Y DIRECCIÓN DE EMPRESAS 

\vspace{0.4cm}

\large
Curso Académico 2021/2022

\vspace{0.8cm}

Trabajo Fin de Grado

\vspace{2.5cm}

\LARGE
ANÁLISIS DE DATOS DEL PENSAMIENTO COMPUTACIONAL DE PROYECTOS DE SCRATCH Y SNAP!

\vspace{3cm} 

\large
Autora : Rosa Cristina Ruiz Rivas \\
Tutor : Dr. Gregorio Robles Martínez
\end{center}
\end{titlepage}

\newpage
\mbox{}
\thispagestyle{empty} % para que no se numere esta pagina


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Para firmar
\clearpage
\pagenumbering{gobble}
\chapter*{}

\vspace{-4cm}
\begin{center}
\LARGE
\textbf{Trabajo Fin de Grado}

\vspace{1cm}
\large
Análisis de Datos del Pensamiento Computacional de Proyectos de Scratch y Snap!

\vspace{1cm}
\large
\textbf{Autora :} Rosa Cristina Ruiz Rivas \\
\textbf{Tutor :} Dr. Gregorio Robles Martínez

\end{center}

\vspace{1cm}
La defensa del presente Proyecto Fin de Grado se realizó el día \qquad$\;\,$ de \qquad\qquad\qquad\qquad \newline de 2022, siendo calificada por el siguiente tribunal:


\vspace{0.5cm}
\textbf{Presidente:}

\vspace{1.2cm}
\textbf{Secretario:}

\vspace{1.2cm}
\textbf{Vocal:}


\vspace{1.2cm}
y habiendo obtenido la siguiente calificación:

\vspace{1cm}
\textbf{Calificación:}


\vspace{1cm}
\begin{flushright}
Fuenlabrada, a \qquad$\;\,$ de \qquad\qquad\qquad\qquad de 2022
\end{flushright}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Dedicatoria

\chapter*{}
\pagenumbering{Roman} % para comenzar la numeracion de paginas en numeros romanos
\begin{flushright}
\textit{Dedicado a \\
mi familia / mi abuelo / mi abuela}
\end{flushright}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Agradecimientos

\chapter*{Agradecimientos}
%\addcontentsline{toc}{chapter}{Agradecimientos} % si queremos que aparezca en el índice
\markboth{AGRADECIMIENTOS}{AGRADECIMIENTOS} % encabezado 

Aquí vienen los agradecimientos\ldots Aunque está bien acordarse de la pareja, no hay que olvidarse de dar las gracias a tu madre, que aunque a veces no lo parezca disfrutará tanto de tus logros como tú\ldots 
Además, la pareja quizás no sea para siempre, pero tu madre sí.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Resumen

\chapter*{Resumen}
%\addcontentsline{toc}{chapter}{Resumen} % si queremos que aparezca en el índice
\markboth{RESUMEN}{RESUMEN} % encabezado

Aquí viene un resumen del proyecto.
Ha de constar de tres o cuatro párrafos, donde se presente de manera clara y concisa de qué va el proyecto. 
Han de quedar respondidas las siguientes preguntas:

\begin{itemize}
  \item ¿De qué va este proyecto? ¿Cuál es su objetivo principal?
  \item ¿Cómo se ha realizado? ¿Qué tecnologías están involucradas?
  \item ¿En qué contexto se ha realizado el proyecto? ¿Es un proyecto dentro de un marco general?
\end{itemize}

Lo mejor es escribir el resumen al final.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Resumen en inglés

\chapter*{Summary}
%\addcontentsline{toc}{chapter}{Summary} % si queremos que aparezca en el índice
\markboth{SUMMARY}{SUMMARY} % encabezado

Here comes a translation of the ``Resumen'' into English. 
Please, double check it for correct grammar and spelling.
As it is the translation of the ``Resumen'', which is supposed to be written at the end, this as well should be filled out just before submitting.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ÍNDICES %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Las buenas noticias es que los índices se generan automáticamente.
% Lo único que tienes que hacer es elegir cuáles quieren que se generen,
% y comentar/descomentar esa instrucción de LaTeX.

%%%% Índice de contenidos
\tableofcontents 
%%%% Índice de figuras
\cleardoublepage
%\addcontentsline{toc}{chapter}{Lista de figuras} % para que aparezca en el indice de contenidos
\listoffigures % indice de figuras
%%%% Índice de tablas
%\cleardoublepage
%\addcontentsline{toc}{chapter}{Lista de tablas} % para que aparezca en el indice de contenidos
%\listoftables % indice de tablas


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% INTRODUCCIÓN %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Introducción}
\label{sec:intro} % etiqueta para poder referenciar luego en el texto con ~\ref{sec:intro}
\pagenumbering{arabic} % para empezar la numeración de página con números

Nos encontramos inmersos en una transformación digital sin precedentes, donde saber gestionar grandes volúmenes de datos  de diversas fuentes, automatizar procesos, aplicar algoritmos para que los dispositivos aprendan y sean capaces de predecir lo que se necesita, realizando acciones de manera autónoma, se ha convertido en una necesidad imperante en la sociedad. Para ello es indispensable que tanto niños como jóvenes desarrollen habilidades que les permitan no solo consumir tecnología, sino comprender las bases que la sustentan, siendo capaces de resolver problemas cada vez más complejos, buscando nuevas soluciones y creando tecnología.

%desde edades tempranas creando tecnología hackers, makers, sociedad eminentemente tecnológica.  
Es de vital importancia que en todas las etapas educativas se fomente el aprendizaje y la aplicación del \textit{pensamiento computacional (PC)}, 
de manera transversal e incremental, de forma que el alumno se implique y esté motivado con el proceso pudiendo formular un problema, descomponer el problema en partes más sencillas, abstraer lo relevante y aplicable en otras circunstancias, identificar distintas acciones a realizar ante diversas entradas y expresar soluciones (véase apartado~\ref{subsec:pc}). Han sido muchos los investigadores encargados de difundir y tratar de evaluar el \textit{pensamiento computacional (PC)}, desde distintas perspectivas. Uno de los enfoques es el propuesto en Dr. Scratch y desarrollado por alumnos e investigadores de la URJC.

A partir de las prácticas realizadas en Programamos consistentes en la obtención de datos de un conjunto de 269844 proyectos de Scratch almacenados en el servidor de Dr. Scratch, para poder determinar las relaciones existentes entre las siete dimensiones del pensamiento computacional y establecer rutas de aprendizaje, mi tutor -Dr. Gregorio Robles- me propuso realizar un análisis de datos de los 113906 proyectos de Snap! Este Trabajo de Fin de Grado busca determinar a partir de un análisis exhaustivo y descriptivo cuales son las pautas seguidas en los proyectos de Snap! y Scratch en cuanto a las puntuaciones obtenidas a nivel general y para cada capacidad analizada del pensamiento computacional. 

%En este capítulo se introduce el proyecto.
%Debería tener información general sobre el mismo, dando la información sobre el contexto en el que se ha desarrollado.
%
%No te olvides de echarle un ojo a la página con los cinco errores de escritura más frecuentes\footnote{\url{http://www.tallerdeescritores.com/errores-de-escritura-frecuentes}}.
%
%Aconsejo a todo el mundo que mire y se inspire en memorias pasadas.
%Las memorias de los proyectos que he llevado yo están (casi) todas almacenadas en mi web del GSyC\footnote{\url{https://gsyc.urjc.es/~grex/pfcs/}}.


\section{Contexto}
\label{sec:contexto}

\subsection{Pensamiento computacional (PC)}
\label{subsec:pc}
Seymour Papert desarrolló el lenguaje de programación \texttt{Logo} en 1967 junto a Daniel Bobrow, Wallace Feurzeig, Cynthia Solomon y Dick Grant en Bolt, Beranek and Newman, Inc. (BBN), con fines pedagógicos~\cite{solomon20:_history}. A partir de 1969 continuaron su investigación en los Laboratorios de Inteligencia Artificial del MIT, junto a Marvin Minsk. Fue el primero en mencionar el \emph{pensamiento computacional} relacionándolo con el construccionismo, una nueva forma de aprendizaje donde el alumno es la parte activa~\cite{papert80:_mindstorm}.

El niño programa al ordenador para poder expresar sus ideas cuando se enfrenta a problemas. Se fomenta un proceso de aprendizaje heurístico basado en la exploración y en la experimentación pudiendo aprender de los errores, depurándolos. Se concretizan conceptos abstractos y formales al implementar programas que la ``tortuga'' ejecuta, ya sea como robot o como cursor en la pantalla. Se crea un entorno libre que fomenta la creatividad, donde el niño construye sus propios proyectos, de cualquier temática, a la vez que construye sus estructuras intelectuales, planificando el proyecto, realizando diseños y modelos, mejorando el código e incrementando su complejidad.

El niño como epistemólogo razona sobre su pensamiento al observar el resultado de sus ideas y comprende a través de sus programas cómo secuenciar instrucciones de manera precisa gracias a los algoritmos, cómo manejar variables y cambios de estado, cuándo emplear bucles o recursividad, la conveniencia de aplicar modularidad y descomposición del problema en procedimientos encargados de tareas concretas, cómo extraer lo relevante para resolver problemas similares desarrollando la abstracción, cómo emplear sincronismo y paralelismo para que las tortugas interactúen entre sí. El alumno comprende cuando es más apropiado emplear cada concepto computacional como herramienta para su aprendizaje. Está motivado al sentir el proyecto como propio y aumenta su expresividad al comunicar a los demás los resultados de sus hallazgos, en un entorno colaborativo donde el profesor incentiva las ideas de los alumnos y actúa de soporte. Esta forma de aprendizaje dota de recursos al alumnado para asimilar conceptos de otras materias que serán aplicables a cualquier carrera profesional. 

Jeannette M. Wing popularizó el término definiendo el pensamiento computacional como la capacidad analítica que todas las personas deben desarrollar para resolver problemas en varios niveles de abstracción y diseñar sistemas eficientes en función de su complejidad, aplicando los conceptos fundamentales de la informática~\cite{wing2006computational}. Posteriormente añadió que es el proceso mental que permite formular problemas y encontrar soluciones de forma que un procesador pueda ejecutarlas, combinando para su resolución el razonamiento lógico, los algoritmos y la abstracción, que permite reconocer patrones, generalizar y utilizar la misma función para resolver aquellos subproblemas similares en que se divide el problema complejo inicial~\cite{wing2011research}.

Alfred V. Aho indica que el pensamiento computacional es el ``proceso de pensamiento involucrado al formular problemas de manera que sus soluciones puedan ser representadas como pasos computacionales y algoritmos''~\cite[p. 832]{aho2012computation}. Resalta la importancia de la abstracción para crear y aplicar modelos computacionales.

El marco conceptual de Brennan-Resnick fue elaborado en base a investigaciones y entrevistas a jóvenes diseñadores de proyectos en Scratch. Establece una definición operativa del PC que engloba 3 dimensiones~\cite{brennan2012new}: 
\begin{enumerate}
  \item \textbf{Conceptos computacionales:} Los niños emplean los siguientes conceptos cuando programan sus proyectos de Scratch: \emph{secuencias} de instrucciones definidas, concretas y ordenadas para realizar una actividad; \emph{bucles} o repetición de un conjunto de instrucciones; \emph{eventos} que provocan que se ejecute la secuencia asociada cuando ocurren; \emph{paralelismo} entre secuencias que se ejecutan simultáneamente; \emph{condicionales} o estructuras de control selectivas que deciden las sentencias a ejecutar en función de que se cumpla una situación; \emph{datos} para almacenar, recuperar y actualizar valores y \emph{operadores} para transformar esos datos.  
  \item \textbf{Prácticas computacionales:} Se basan en el proceso de aprendizaje desarrollado al aplicar los conceptos en los proyectos y consisten en: \emph{ser incremental e iterativo}; \emph{evaluar y depurar} cada secuencia aplicando técnicas de prueba y error;
  \emph{reutilizar y remezclar} programas preexistentes compartidos por otros usuarios para hacer modificaciones o combinaciones que permitan solucionar nuestro problema, y \emph{abstraer y modular} al construir a partir de programas concretos un proyecto más complejo y en el que algunas de las partes sean resueltas por la misma función tras descartar los detalles irrelevantes.
  
  \item \textbf{Perspectivas computacionales:} \emph{expresar} ideas y crear tecnología en función de sus intereses; \emph{conectar} con otros a través de la comunidad online de Scratch para compartir proyectos y dudas incrementando la creatividad y el aprendizaje, y \emph{cuestionar} el funcionamiento de la tecnología que los rodea y ser capaces de transformarla.
\end{enumerate} 


``El pensamiento computacional es la capacidad de formular y representar problemas para resolverlos mediante el uso de herramientas, conceptos y prácticas de la disciplina informática, como la abstracción, la descomposición o el uso de simulaciones''\footnote{\url{https://programamos.es/pensamiento-computacional-y-programacion-no-son-lo-mismo/}}
% El pensamiento computacional parece estar exclusivamente relacionado con la informática y las ciencias de la computación pero es más un proceso cognitivo~\ref{moreno19:_programming} que puede ser desarrollado a partir de la programación, pero también a partir de otras actividades ``desenchufadas''. En nuestro caso, se analiza a partir de dos lenguajes de programación visual en bloques.

Las definiciones planteadas del CT y los elementos que la componen son solo algunas de las propuestas de investigadores de todo el mundo. Puede ser desarrollado con actividades desenchufadas o ``unplugged'', programación visual con bloques o programación textual con lenguajes como python. En este caso se emplean dos lenguajes de programación visual con bloques: Scratch y Snap! \ldots

Gracias a la colaboración de investigadores, asociaciones, empresas, gobiernos y educadores el CT se enseña en las escuelas de una gran cantidad de países, por el reconocimiento de que es una habilidad clave a desarrollar tan importante como leer, escribir y la arimética. Los profesores deben formarse para introducir el pensamiento computacional en las aulas, para que el desconocimiento de cómo hacerlo no sea un impedimento para que las nuevas generaciones sean capaces de crear y hacer las innovaciones del futuro en las carreras profesionales que elijan.

\subsection{Análisis de datos}
\label{subsec:analisis_datos}
EDA, \emph{ML}

%  KDD (Knowledge Discovery in Databases) para referirse al (amplio) concepto de hallar conocimiento en los datos, SEMMA no CRISP-DM Analisis de datos
% Tomar decisiones en base a datos. Resolver problemas de manera organizada

% CRISP-DM se diseñó pensando en los procesos asociados para cumplir los objetivos del proyecto, mientras que el nuevo enfoque de ciencia de datos requiere una aproximación más flexible que ponga el dato en el centro. Esta nueva perspectiva implica que los propios objetivos negocio podrían no estar disponibles al principio del proyecto, y que se tendrían que incluir en la metodología actividades de carácter exploratorio que ayuden a determinarlo a través de análisis sobre los propios datos.
%Planning   problem   solving,   natural   language   processing, knowledge  representation,
%expert  systems,  neural  networks,  machine  learning,  robotic and  computer  vision  are  some  of  the  most  successful  and  broadly  used  in  current applications.  
% McCarthy, Minsky, Rochester and Shannon during a workshop held  in  Dartmouth  in  the  summer  of 1956
%El pensamiento computacional se emplea en otras disciplinas para poder almacenar, recuperar, procesar y visualizar masivas cantidades de datos, obteniendo modelos con una abstracción elevada ~\cite{wing2011research}.  https://people.cs.vt.edu/~kafura/CS6604/Papers/CT-What-And-Why.pdf
% , researchers in all disci-plines—including the arts, humanitiesand social sciences—are discovering new knowledge using computational methods and tools.
% Working with data skills: problem analysis, data collection, sorting, search and data management, content quality evaluation
% third pillar of science, along with theory and experimentation
% Storing, retrieving and updating values. Making sense of data by
% finding patterns or developing insights (Basu et al., 2017).

%El análisis de los datos es el ``proceso de inspección, limpieza, transformación y modelado de datos con el objetivo de descubrir información útil, conclusiones informadas y servir de soporte en la toma de decisiones''. Hay 4 tipos:% cada uno incluye al anterior. Picture
%- Análisis descriptivo <-- Qué ha sucedido. Resumen de los datos visualización y estadística. Describir y resumir
%- Análisis de diagnóstico, ¿Por qué ha sucedido? cuales son las causas de estas salidas. Buscar causas y soluciones
%- Análisis predictivo, Qué es probable que suceda.
%utilizas los datos del pasado para predecir lo que pasará en el futuro. El análisis predictivo combina datos históricos y modelos estadísticos para pronosticar cómo se comportarán ciertas métricas en el futuro.  Los métodos van desde tomar promedios hasta entrenar algoritmos de agrupamiento u otros modelos de aprendizaje automático
%- Análisis prescriptivo, Cómo hacer que suceda. Se utiliza todo lo descubierto en los datos con los análisis previos para plantear acciones y decisiones de un negocio.

% Problemas principales a resolver, escuchar a otros componentes del equipo, realizar las preguntas correctas al inicio agiliza el trabajo. Problemas más importantes que necesitan insights para tomar decisiones.
% Extraer información relevante a partir de la representación de los datos, visualización de los datos

%Visualización de datos: Crear representaciones gráficas de la información para facilitar su interpretación, la extracción de conclusiones y la toma de decisiones. Depende del tipo de datos con el que se trabaje.
%Pandas: leer y manipular los datos para responder a preguntas desde los datos.(Análisis de datos), Conteo medias, std, 25 percentiles...
%Seleccionar, manipular, filtrar, merge, melt, groupby, pivot agrupar datos 
%Importancia de graficar siempre los datos

% Convertir realidades de comportamientos humanos en datos y esos datos en información para entender qué está pasando Explicar la realidad que se esconde detrás de los datos como se interpretan. los distintos canales de visualización

% Dar sentido a los datos mediante la búsqueda de patrones o el desarrollo de conocimientos (insights). Qué quieres conseguir con tus datos.Qué preguntas quieres contestar con tus datos. limpiar y organizar los datos...Representación de datos Representar y organizar datos en gráficos, tablas, palabras o imágenes apropiados.

% Data driven .... Tomar decisiones basado en datos.
% John Tukey the future of data analysis,,eda  libros 

\section{Motivación}
\label{sec:motivación}

\section{Sección}
\label{sec:seccion}

Esto es una sección, que es una estructura menor que un capítulo. 

Por cierto, a veces me comentáis que no os compila por las tildes.
Eso es un problema de codificación.
Al guardar el archivo, guardad la codificación de ``ISO-Latin-1'' a ``UTF-8'' (o viceversa) y funcionará.

\subsection{Estilo}
\label{subsec:estilo}

Recomiendo leer los consejos prácticos sobre escribir documentos científicos en \LaTeX \ de Diomidis Spinellis\footnote{\url{https://github.com/dspinellis/latex-advice}}.

Lee sobre el uso de las comas\footnote{\url{http://narrativabreve.com/2015/02/opiniones-de-un-corrector-de-estilo-11-recetas-para-escribir-correctamente-la-coma.html}}. 
Las comas en español no se ponen al tuntún.
Y nunca, nunca entre el sujeto y el predicado (p.ej. en ``Yo, hago el TFG'' sobre la coma).
La coma no debe separar el sujeto del predicado en una oración, pues se cortaría la secuencia natural del discurso.
No se considera apropiado el uso de la llamada coma respiratoria o \emph{coma criminal}.
Solamente se suele escribir una coma para marcar el lugar que queda cuando omitimos el verbo de una oración, pero es un caso que se da de manera muy infrecuente al escribir un texto científico (p.ej. ``El Real Madrid, campeón de Europa'').

A continuación, viene una figura, la Figura~\ref{figura:foro_hilos}. 
Observarás que el texto dentro de la referencia es el identificador de la figura (que se corresponden con el ``label'' dentro de la misma). 
También habrás tomado nota de cómo se ponen las ``comillas dobles'' para que se muestren correctamente. 
Nota que hay unas comillas de inicio (``) y otras de cierre (''), y que son diferentes.
Volviendo a las referencias, nota que al compilar, la primera vez se crea un diccionario con las referencias, y en la segunda compilación se ``rellenan'' estas referencias. 
Por eso hay que compilar dos veces tu memoria.
Si no, no se crearán las referencias.

 \begin{figure}
    \centering
    \includegraphics[bb=0 0 800 600, width=12cm, keepaspectratio]{img/foro1}
    \caption{Página con enlaces a hilos}
    \label{figura:foro_hilos}
 \end{figure}

A continuación un bloque ``verbatim'', que se utiliza para mostrar texto tal cual.
Se puede utilizar para ofrecer el contenido de correos electrónicos, código, entre otras cosas.

{\footnotesize
\begin{verbatim}
    From gaurav at gold-solutions.co.uk  Fri Jan 14 14:51:11 2005
    From: gaurav at gold-solutions.co.uk (gaurav_gold)
    Date: Fri Jan 14 19:25:51 2005
    Subject: [Mailman-Users] mailman issues
    Message-ID: <003c01c4fa40$1d99b4c0$94592252@gaurav7klgnyif>

    Dear Sir/Madam,
    How can people reply to the mailing list?  How do i turn off
    this feature? How can i also enable a feature where if someone
    replies the newsletter the email gets deleted?
    Thanks

    From msapiro at value.net  Fri Jan 14 19:48:51 2005
    From: msapiro at value.net (Mark Sapiro)
    Date: Fri Jan 14 19:49:04 2005
    Subject: [Mailman-Users] mailman issues
    In-Reply-To: <003c01c4fa40$1d99b4c0$94592252@gaurav7klgnyif>
    Message-ID: <PC173020050114104851057801b04d55@msapiro>

    gaurav_gold wrote:
    >How can people reply to the mailing list?  How do i turn off
    this feature? How can i also enable a feature where if someone
    replies the newsletter the email gets deleted?

    See the FAQ
    >Mailman FAQ: http://www.python.org/cgi-bin/faqw-mm.py
    article 3.11
\end{verbatim}
}

\section{Estructura de la memoria}
\label{sec:estructura}

En esta sección se debería introducir la esctura de la memoria. 

Así:

\begin{itemize}
  \item En el primer capítulo se hace una intro al proyecto.
  
  \item En el capítulo~\ref{chap:objetivos} (ojo, otra referencia automática) se muestran los objetivos del proyecto.
  
  \item A continuación se presenta el estado del arte en el capítulo~\ref{chap:estado}.
  
  \item \ldots
\end{itemize}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% OBJETIVOS %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage % empezamos en página impar
\chapter{Objetivos} % título del capítulo (se muestra)
\label{chap:objetivos} % identificador del capítulo (no se muestra, es para poder referenciarlo)

\section{Objetivo general} % título de sección (se muestra)
\label{sec:objetivo-general} % identificador de sección (no se muestra, es para poder referenciarla)

Aquí vendría el objetivo general en una frase:
Mi trabajo fin de grado consiste en crear de una herramienta de análisis de los comentarios jocosos en repositorios de software libre alojados en la plataforma GitHub.

Recuerda que los objetivos siempre vienen en infinitivo.


\section{Objetivos específicos}
\label{sec:objetivos-especificos}

Los objetivos específicos se pueden entender como las tareas en las que se ha desglosado el objetivo general.
Y, sí, también vienen en infinitivo.


\section{Planificación temporal}
\label{sec:planificacion-temporal}

A mí me gusta que aquí pongáis una descripción de lo que os ha llevado realizar el trabajo.
Hay gente que añade un diagrama de GANTT.
Lo importante es que quede claro cuánto tiempo llevas (tiempo natural, p.ej., 6 meses) y a qué nivel de esfuerzo (p.ej., principalmente los fines de semana).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ESTADO DEL ARTE %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Estado del arte}
\label{chap:estado}

\section{Scratch}
\label{sec:scratch}
Lenguaje de programación visual con bloques que permite la implementación desde el navegador web. 
Resnick influenciado por Seymour Papert
% Creatividad en la búsqueda de diferentes soluciones a un mismo problema...

\section{Dr. Scratch}
\label{sec:dr_scratch}

Dr. Scratch\footnote{\url{http://www.drscratch.org}} es una aplicación web open-source que analiza proyectos programados en Scratch a través de su url o en formato .sb3 extrayendo el JSON correspondiente y comprobando a partir de los bloques utilizados cuáles son las destrezas del pensamiento computacional demostradas en los proyectos. De manera automática el alumno, profesor o programador de cualquier edad obtiene realimentación para mejorar en las áreas en las que menor puntuación obtenga, así como de las malas prácticas cometidas~\cite{moreno2015dr}
% tabla de métricas PC %CT formative–iterative tools
% Arquitectura muy por encima????

% https://www.researchgate.net/publication/333670771_Combining_Assessment_Tools_for_a_Comprehensive_Evaluation_of_Computational_Thinking_Interventions#pf13
% It analyzes the code and, depending of the diversity of blocks used, the application gives a score to the project http://ceur-ws.org/Vol-2434/paper2.pdf

% Scratch Crear y compartir ideas, para inspirarse y recibir realimentación


%%%%%%%%% ponle dos páginas por cada cosa, con una captura para cada una, y una tabla para cada una con lo que se evalúa para Dr. Scratch y Dr. Snap.
% Definir bloques funciones de cada categoría.
% Funciones, listas, continuaciones de primera clase.
% Sprites y clones, herencia de sprites
% Funciones lambda

\section{Snap!}
\label{sec:snap}

\section{Dr. Snap!}
\label{sec:dr_snap}

\section{Python}
\label{sec:python}

\section{Jupyter Notebooks}
\label{sec:jupyter}

%\section{Numpy} 
%\label{sec:numpy}

\section{Pandas} 
\label{sec:pandas}

\section{Matplotlib} 
\label{sec:matplotlib}

\section{Seaborn} 
\label{sec:seaborn}

\section{Scikit Learn} 
\label{sec:sklearn}


Descripción de las tecnologías que utilizas en tu trabajo. 
Con dos o tres párrafos por cada tecnología, vale. 
Se supone que aquí viene todo lo que no has hecho tú.

Puedes citar libros, como el de Bonabeau et al., sobre procesos estigmérgicos~\cite{bonabeau:_swarm}. 
Me encantan los procesos estigmérgicos.
Deberías leer más sobre ellos.
Pero quizás no ahora, que tenemos que terminar la memoria para sacarnos por fin el título.
Nota que el \~ \ añade un espacio en blanco, pero no deja que exista un salto de línea. 
Imprescindible ponerlo para las citas.

Citar es importantísimo en textos científico-técnicos. 
Porque no partimos de cero.
Es más, partir de cero es de tontos; lo suyo es aprovecharse de lo ya existente para construir encima y hacer cosas más sofisticadas.
¿Dónde puedo encontrar textos científicos que referenciar?
Un buen sitio es Google Scholar\footnote{\url{http://scholar.google.com}}.
Por ejemplo, si buscas por ``stigmergy libre software'' para encontrar trabajo sobre software libre y el concepto de \emph{estigmergia} (¿te he comentado que me gusta el concepto de estigmergia ya?), encontrarás un artículo que escribí hace tiempo cuyo título es ``Self-organized development in libre software: a model based on the stigmergy concept''.
Si pulsas sobre las comillas dobles (entre la estrella y el ``citado por ...'', justo debajo del extracto del resumen del artículo, te saldrá una ventana emergente con cómo citar.
Abajo a la derecha, aparece un enlace BibTeX.
Púlsalo y encontrarás la referencia en formato BibTeX, tal que así:

{\footnotesize
\begin{verbatim}
@inproceedings{robles2005self,
  title={Self-organized development in libre software:
         a model based on the stigmergy concept},
  author={Robles, Gregorio and Merelo, Juan Juli\'an 
          and Gonz\'alez-Barahona, Jes\'us M.},
  booktitle={ProSim'05},
  year={2005}
}
\end{verbatim}
}

Copia el texto en BibTeX y pégalo en el fichero \texttt{memoria.bib}, que es donde están las referencias bibliográficas.
Para incluir la referencia en el texto de la memoria, deberás citarlo, como hemos hecho antes con~\cite{bonabeau:_swarm}, lo que pasa es que en vez de el identificador de la cita anterior (bonabeau:\_swarm), tendrás que poner el nuevo (robles2005self).
Compila el fichero \texttt{memoria.tex} (\texttt{pdflatex memoria.tex}), añade la bibliografía (\texttt{bibtex memoria.aux}) y vuelve a compilar \texttt{memoria.tex} (\texttt{pdflatex memoria.tex})\ldots y \emph{voilà} ¡tenemos una nueva cita~\cite{robles2005self}!

También existe la posibilidad de poner notas al pie de página, por ejemplo, una para indicarte que visite la página del GSyC\footnote{\url{http://gsyc.es}}.

\section{Sección 1} 
\label{sec:seccion1}

Hemos hablado de cómo incluir figuras.
Pero no hemos dicho nada de tablas.
A mí me gustan las tablas.
Mucho.

Aquí un ejemplo de tabla, la Tabla~\ref{tabla:ejemplo}
(siento ser pesado, pero nota cómo he puesto la referencia).

\begin{table}[H]
 \begin{center}
  \begin{tabular}{ | l | c | r |} % tenemos tres colummnas, la primera alineada a la izquierda (l), la segunda al centro (c) y la tercera a la derecha (r). El | indica que entre las columnas habrá una línea separadora.
    \hline
    Uno & 2 & 3 \\ \hline % el hline nos da una línea vertical
    Cuatro & 5 & 6 \\ \hline
    Siete & 8 & 9 \\
    \hline
  \end{tabular}
  \caption{Ejemplo de tabla. Aquí viene una pequeña descripción (el \emph{caption}) del contenido de la tabla. Si la tabla no es autoexplicativa, siempre viene bien aclararla aquí.}
  \label{tabla:ejemplo}
 \end{center}
\end{table}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DISEÑO E IMPLEMENTACIÓN %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Diseño e implementación}

% Análisis descriptivo cuantitativo basado en las métricas establecidas en Dr. Scratch y las modificadas en Dr. Snap! Apartado 6.1.1 Explicando acceso a BBDD del servidor. Análisis estático.
% Es mejor tener una respuesta aproximada a la pregunta correcta, que una respuesta exacta a la pregunta equivocada. Tukey

En la fase de documentación se estudiaron las distintas tecnologías comentadas en el capítulo~\ref{chap:estado}, para conocer las métricas que ponderan el desarrollo del pensamiento computacional tanto en Dr. Scratch como en Dr. Snap! El objetivo era extraer patrones, tendencias y relaciones entre las habilidades a partir de un volumen de proyectos suficientemente amplio y representativo de ambas poblaciones para así poder compararlas. Se recurre a un análisis de datos descriptivo cuantitativo para explorar y conocer la información que se desprende al aplicar técnicas estadísticas y de visualización de datos. Se muestra en la figura~\ref{fig:diseño} el proceso y el diseño del script implementado. Lo obtenido en cada paso acota las herramientas a emplear en el siguiente. %En un análisis exploratorio, el conocimiento adquirido de los datos en cada etapa marca qué hacer en la siguiente. Responder preguntas en base a los datos.

% Diseño del script
\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{img/diseno_script_2.png}
    \caption{Diagrama del proceso de análisis de datos}\label{fig:diseño}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Importancia del contexto. Entendimiento de los datos que se necesitan. Fuente de los datos. Obtención y selección de datos. Solicitadas a las APIs Interacción con el servidor de Snap! Tras procesarlos se representan los datos en un csv.
Para ambos análisis se debían recolectar los proyectos almacenados en una base de datos e implementar un script que automatizara la recogida de las métricas de cada proyecto, las guardara en un fichero CSV para, posteriormente, cargarlo con Pandas y realizar el análisis de datos en los Jupyter Notebooks. Para completar la preparación de los datos se requiere eliminar datos espurios que distorsionen su comprensión, descartando de la muestra los proyectos duplicados o con atributos incompletos. Se formatean mediante la conversión de tipos de las variables o columnas que los caracterizan, que facilite su estudio estadístico, su representación gráfica y el entendimiento de lo que representan. % reducción del tiempo de cómputo ante un gran volumen de datos, que puedan ser procesados. Limpiar y categorizar los datos.

En la tercera etapa se comienza a conocer cómo se distribuyen los proyectos en función del nivel alcanzado, la valoración total conseguida y las puntuaciones obtenidas en cada unas de las siete habilidades del pensamiento computacional. Se filtran, combinan y agrupan los valores de las columnas para analizar la competencia demostrada general y particular para cada destreza considerada de las ciencias de la computación. % tendencias de la distribución.

Posteriormente, se calculan los estadísticos que resumen las propiedades de las variables en cuanto a tendencia central, dispersión y posición, pudiendo perfilar que habilidades resultan más fáciles y si sus métricas están muy concentradas. %% Se completa el análisis de las distribuciones anterior y se vislumbran ciertas relaciones en las distribuciones.

Se completa el análisis exploratorio de datos (EDA) tratando de encontrar las relaciones y dependencias entre las habilidades gracias a las correlaciones, considerando todos los proyectos y desglosándolos según la puntuación total conseguida, para ver su evolución según aumenta la complejidad de los proyectos.

Para descubrir similitudes entre los proyectos ocultas a simple vista, se aplica un modelo de aprendizaje no supervisado, el clustering K-Means. Segmenta la totalidad de los proyectos en k grupos, aplicando un criterio de mínima distancia al centro del grupo, según su posición definida por las siete dimensiones. Se estima el valor de k, ya sea con herramientas de validación externa o con índices que relacionan las distancias intra-clúster o inter-clúster, escogiendo el valor de k que los minimice o los maximice, según sea el caso, o donde convergan diferentes criterios. Una vez tenemos el valor de k, se ejecuta iterativamente el algoritmo K-Means hasta encontrar la posición óptima de los proyectos representativos del grupo. Éstos pueden interpretarse como prototipos en el proceso de aprendizaje.

\section{Recolección y extracción de datos}  
\label{sec:collect_data}

% en el disco duro del servidor, en GCP
Cuando se analiza con Dr. Scratch un proyecto, ya sea a través de su url o cargando el proyecto de Scratch desde el ordenador, se almacena una copia del proyecto en la base de datos MySQL en los formatos comprimidos propios de Scratch, según la versión de Scratch utilizada para implementarlo. La mayoría de los proyectos pertenecen a la versión 3.0 de Scratch que se corresponde con la extensión .sb3. No obstante, algunas de las copias salvadas cuentan con extensiones .sb2 y .sb, vinculadas a versiones antiguas. % ojo se comprueba y cambia la versión. Por lo general son .sb3, ya que se replicó la fucionalidad de Hairball y se integró en Dr. Scratch Django==1.11.11 python==2.7

% Desplegada en PaaS en Google Cloud con un Servidor de Apache ---- donde está alojado Dr. Scratch. Arquitectura LAMP. 
% autentificación por clave pública-privada
% directorio /var/www/drscratchv3/uploads/
Se accedió al servidor en remoto vía ssh mediante clave pública-privada para descargar los 271558 proyectos de Scratch que se encontraban en el directorio \texttt{drscratchv3/uploads/}. Ocupaban cerca de 80GB y estaban fechados entre el 1 junio de 2019 y el 31 de julio de 2021. Se fueron copiando por lotes en local, gracias a scp y rsync, en función del mes y año. % filtrándolos por mes y año, redirigiendo la lista de los proyectos a copiar a un fichero que es transferido a una carpeta local con scp e indicando a rsync cuales son los proyectos a copiar, permitiendo la sincronización de archivos, de manera que solo se reciban los proyectos que han cambiado o no han sido transferidos desde el servidor remoto a local, si falla la conexión.
%  autentificación por clave pública-privada requerida para descargar los proyectos por scp a un archivo con los ficheros encontrados según mes y año y despues emplear rsync para descargar los proyectos sb3.

%Se almacena en formato sb3 el que viene por url. Se solicita el JSON a los servidores del MIT, se comprueba si viene bien... /utemp.... Se registra el análisis en un fichero logFile, guarda el proyecto en /uploads% y luego analiza el PC.
%JSON es una alternativa para el intercambio de documentos. Sintaxis con la misma estructura de datos básica que diccionarios y listas. Aplicaciones  peticiones a un servidor. El servidor me devuelve datos en formato JSON.  Es más simple no hay validadores, un formato más compacto. Es fácil de leer, consume menos ancho de banda.

% automatiza el análisis desde línea de comandos.
El módulo \texttt{analyzer.py} de Dr. Scratch asigna puntuaciones a cada una de las 7 habilidades del pensamiento computacional en función de los bloques empleados. Para ello, analiza el documento JSON que almacena el código fuente de cada proyecto, ubicado en el directorio comprimido. Se adaptó el módulo para que pudiera ser ejecutado desde línea de comandos como programa principal, pasándole como argumento el proyecto de Scratch a analizar (en formato comprimido .sb*) o la ruta al mismo. Se modificó para que imprimiera por pantalla las métricas de cada habilidad, el total obtenido al sumarlas y la valoración media para cada proyecto, en una fila separada por comas. Se redirigió la salida estándar al fichero \emph{results.csv}.  
Con un bucle for en bash scripting se automatizó el análisis para todos los lotes de proyectos, indicando el path al directorio donde se localizan. El flujograma del script se representa en~\ref{fig:script_extract} 

% JSON con formato inválido
Aquellos proyectos que generaban excepciones por fallos en la descompresión del proyecto, en la conversión del objeto JSON a un diccionario o en el acceso y obtención de elementos o claves al recorrer la estructura de diccionarios anidados, fueron registrados redirigiendo el flujo de errores estándar, \emph{stderr}, al fichero \texttt{error.csv}. Este fichero indicaba la ruta al proyecto, el tipo de excepción capturada y la línea donde se produce. Contenía 1714 proyectos excluidos del análisis de datos posterior.
% KeyError, AttributeError, RecursionError, zipfile.BadZipFile, json.decoder.JSONDecodeError. Excepciones volcadas.


\begin{figure}
    \centering
    \includegraphics[height=.7\textheight]{img/script_extraccion_datos.png}
    \caption{Diagrama de flujo del script get\_csv}
    \label{fig:script_extract}
\end{figure}

%{\footnotesize
%\begin{verbatim}

%for i in *.sb*; do python3 /home/rcruiz/Programamos_DrScratch3/ProyectosScratchRosa/analyzer.py "$i" >> resultados.csv; done

%for i in *.sb*; do python3 /home/rcruiz/Programamos_DrScratch3/ProyectosScratchRosa/analyzer.py "$i" 2>> error.csv; done
%\end{verbatim}
%}

Para los proyectos de Snap!, mi tutor, Gregorio, me pasó un enlace a un archivo comprimido. Se transfirió su contenido a un disco duro externo. El directorio generado ocupaba 31,9 GB e incluía 113906 proyectos almacenados cada uno en un directorio distinto.

Para extraer la información seleccionada de esta fuente de datos se codificó un script de python, \texttt{get\_csv.py} cuyo diagrama se muestra en~\ref{fig:script_extract}. Si se ejecuta como programa principal, se crea el fichero \emph{result\_snap\_metrics.csv}. Gracias a la librería \texttt{glob}, se recorre una lista con las rutas a los proyectos de Snap! conforme a un patrón específico y se van rellenando las filas del CSV para cada proyecto según los atributos escogidos. Para ello llama a la función \texttt{calcular\_puntuacion(file\_xml)} del módulo \texttt{analyzer.py}. Este módulo recogía las funciones encargadas de calcular el desarrollo del PC de la lógica de la aplicación web de Dr. Snap! Se adaptó para que el parámetro de entrada de la función \texttt{calcular\_puntuacion(file\_xml)} no sea la url, sino el path del proyecto Snap! a analizar, almacenado como documento XML en un árbol de directorios contenidos en un disco duro externo. Se extrajo a otro módulo la parte encargada de parsear el documento XML, que describe la estructura del código fuente del proyecto solicitado al servidor de Snap! Berkeley. 

En el módulo parser se importa el módulo estándar xml.sax. Se genera un parser SAX que procesa el documento como un stream, de manera que el parser genérico creado lee eventos de interés según se van produciendo, y llama a métodos concretos del manejador que especifican qué hacer cuando encuentra determinadas etiquetas anidadas dentro del nodo raíz o elemento project y cómo tratar algunos de sus atributos. En concreto, guarda el nombre del proyecto, los nombres de los bloques utilizados en cada script contenido dentro de un personaje o sprite, los nombres de los bloques personalizados o funciones propias definidas por el programador, así como los bloques utilizados para su implementación y los nombres de las variables declaradas. Además realiza un recuento de las etiquetas sprite, script, bloque, bloque personalizado y variable que aparecen en el documento XML del proyecto. Esta información se almacena en variables del objeto hasta que el parser encuentra el fin de la etiqueta project. Llama al método de la clase del manejador endElement y se almacenan los datos en un documento JSON. % JSON y XML datos semiestructurados

% extensión de funcionalidad tomada de Dr. Snap
Se define una clase ParserXML cuyo constructor consta de dos atributos: un objeto que es el parser genérico creado a partir de make\_parser() y un manejador que instancia un objeto de la clase myContentHandler, que hereda a su vez de la clase ContentHandler predefinida en el módulo handler de la librería xml.sax. Se vincula el parser con el manejador modificado, para que cuando encuentre eventos de contenido, se desencadene la ejecución de los métodos del manejador con la extensión de funcionalidad indicada anteriormente, tomada de Dr. Snap! La clase recibe como parámetro de entrada la ruta del documento XML con la estructura del proyecto codificado en Snap!, almacenado en el disco duro externo. El parser analiza el fichero XML según el comportamiento indicado en el manejador, salvo que localice en el flujo de datos errores en la sintaxis del XML, caracteres terminales no permitidos o \emph{invalid\_token}. En ese caso el proyecto se registra en un fichero donde se indica el tipo de error que se produce y en qué punto salta la excepción. Todos los documentos XML mal formados fueron corregidos. 

% los datos que nos interesan aprovisionamiento de datos
% cuando se convierte a un objeto python
% que facilita el cálculo de las métricas escogidas para analizar el desarrollo del pensamiento computacional.
Cuando se llama a calcular\_puntuacion desde el módulo principal get\_csv, se instancia un objeto de la clase ParserXML que devuelve un fichero en formato JSON, con el contenido que nos interesa en una estructura de datos más compacta, legible y ligera. Se convierte en un diccionario de listas, que es el parámetro de entrada de las funciones que analizan las habilidades del pensamiento computacional en función de los bloques utilizados en los proyectos, el nº de scripts y el nº de sprites. Se corrigieron duplicidades y se mejoró el código del módulo analyzer.

% Funcionamiento del programa principal o diagrama de script extracción de datos.
Se cambió la puntuación total en vez de como media, como suma de las puntuaciones obtenidas en cada dimensión y se pasó de 4 a 3 niveles de competencia suprimiendo la categoría sin nivel.

Tras realizar el proceso de análisis de datos completo, con todos los proyectos, se comprobó que las métricas que definen cada habilidad no estaban bien calibradas. Se quitó la dimensión de diversidad, por no aportar expresividad. El cálculo de las métricas de abstracción y condicionales fue completamente reformulado. Se incluyó la presencia de clones en el código como componente a evaluar en el proyecto de Snap! Por lo tanto, la descomposición del problema en partes más sencillas una vez definido qué es lo relevante para resolverlo, se mide en función del nº de scripts y de sprites, la declaración de funciones o bloques personalizados codificados por el desarrollador de Snap! y la instanciación de objetos o personajes. Se tiene en cuenta la complejidad incremental, de manera que para obtener 2 puntos se incluyen 2 cualesquiera de las prácticas mencionadas y para obtener la máxima puntuación deben aparecer las 3. Para condicionales se propuso una metodología equivalente, asignando 1 punto cuando se emplea un if o un if-else o algún operador lógico, 2 puntos si se usan dos de estas estructuras selectivas y 3 puntos cuando se aplican todas de manera apropiada.

% Esto te pide una tabla
Para paralelismo, sincronización, control de flujo e interactividad con el usuario, se mapearon los elementos inherentes a cada habilidad de manera diferente, haciendo que las métricas fueran discriminantes y presentaran una dificultad creciente. Mediante ensayo y error se fueron reajustando hasta obtener unas distribuciones y rutas de aprendizaje válidas y con mayor sentido tanto a nivel teórico como práctico. 

%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Está alojado en una máquina virtual en Google Cloud Platform (PaaS) con sistema operativo Linux 18.04


\section{Limpieza y tratamiento de datos} 
\label{sec:clean_data}

A pesar de que se ha tenido especial cuidado en la fase de obtención y selección de datos a partir de ambas fuentes, el script de automatización puede recoger proyectos con campos vacíos o proyectos duplicados. Además es conveniente homogeneizar los datos y ajustar los tipos de las variables que los caracterizan. De esta manera se depuran los datos en crudo obtenidos de \emph{results.csv} y \emph{result\_snap\_metrics.csv} y cargados en la estructura de datos bidimensional o dataframe en sendos \emph{Jupyter Notebooks}\footnote{https://github.com/rcruiz/pruebaCT/blob/main/Dr\_Scratch\_Analysis.ipynb} \footnote{https://github.com/rcruiz/DrSnap-Analysis/blob/main/Dr\_Snap\_complete\_analysis.ipynb}. El proceso seguido en esta segunda etapa se muestra en la figura~\ref{fig:script_clean}. 

\begin{figure}[H]
    \centering
    \includegraphics[height=.6\textheight]{img/script_clean2.png}
    \caption{Diagrama de flujo: limpieza de datos}\label{fig:script_clean}
\end{figure}

A partir de este script se obtienen 269842 proyectos de Scratch y 112894 proyectos de Snap! únicos y válidos con un nivel asignado de tipo categórico y cuyas puntuaciones totales y parciales para cada habilidad del PC son variables discretas. Estos datos determinan el tipo de agrupaciones y distribuciones que visualizar en la siguiente etapa.

%Se definen objetos de tipo df, y se accede a los atributos y metodos que informan sobre duplicidades... Sería ya meter código.
%Cada objeto de la clase dataframe de la librería Pandas instanciado

%base de datos estructurada raw data datos en crudo convertirlos en información poder comprender esos datos.
%Buscar tendencias en los datos Transformar los datos en conocimiento. 


\section{EDA univariante: distribuciones por nivel, total y dimensiones CT} 
\label{sec:EDA_univariante}

Las observaciones o proyectos de Scratch y de Snap! recogidos en la estructura de datos tabular por sí mismas no aportan mucha información. Para comenzar a describir y resumir los datos de ambas poblaciones se filtran en función del nivel, que es una variable categórica ordinal con 3 posibles valores: básico, intermedio y avanzado. Se recurre al método value\_counts() de Pandas para determinar las frecuencias de ocurrencia y se ordenan de menor a mayor nivel. Se preparan los datos para ser representados como diagrama de barras y de sectores, gracias a las funciones pertinentes de las bibliotecas seaborn y matplotlib.pyplot.  

\begin{figure}[H]
    \centering
    \includegraphics[height=.5\textheight]{img/diseno_distribucion}
    \caption{Diseño de etapa EDA univariante: distribuciones}\label{fig:eda_uni}
\end{figure}

Para continuar indagando en este análisis exploratorio de datos, los proyectos de cada nivel son ordenados y filtrados según la puntuación total conseguida. Al representar los resultados en un diagrama de barras, podemos descubrir tendencias y conocer las puntuaciones más frecuentes en cada nivel.
Se concatenan los dataframes de cada nivel para obtener un diagrama de barras con la frecuencia de ocurrencia de cada puntuación total. Con ello se vislumbra la distribución de los proyectos según su puntuación total, si existen asimetrías hacia las puntuaciones más bajas y las modas de la distribución.

Se instancia un objeto de la clase dataframe escogiendo las siete variables discretas que definen las capacidades del pensamiento computacional consideradas, llamado \texttt{df\_ct}. Se realiza un estudio unidimensional al agrupar los proyectos según la valoración recibida de 0 a 3 en cada dimensión. Se obtiene por iteración el objeto \texttt{df\_score\_ct}, con 4 filas y 7 columnas, gracias al método \texttt{groupby()} de Pandas. Así se pueden comparar las distribuciones de cada habilidad y la dificultad que entraña desarrollarlas, en base al extenso volumen de proyectos analizados. Además de conocer que habilidades resultan más fáciles, también se distingue si las métricas empleadas son consistentes con un grado de complejidad creciente para cada dimensión.

\section{EDA: resumen por métricas estadísticas} 
\label{sec:EDA_estadísticos}

Se llama al método describe() del objeto \texttt{df\_ct} para obtener, de cada variable discreta del pensamiento computacional, su media, su desviación típica, el rango de valores, la posición de sus cuartiles cuando se ordenan los proyectos de menor a mayor puntuación y su mediana, que coincide con el segundo cuartil. La media y la mediana describen cada distribución por el centro de gravedad o la puntuación del proyecto situado en su centro. Con ellas podemos saber qué habilidades consiguen mejores puntuaciones. Con la varianza y la desviación típica se conoce la dispersión de los proyectos con respecto a la media. 

Se representa el diagrama de cajas de las habilidades con la función \texttt{boxplot()}. Nos permite comparar las distribuciones en función de su rango intercuartílico ($IQR=Q_3 - Q_1$), los límites superior e inferior calculados a partir de él y la presencia de \emph{outliers} o valores atípicos. Se analizan en detalle en los apartados~\ref{subsec:estad_pc_Scratch} y~\ref{subsec:estad_pc_Snap}.   

%Se muestra además en la tabla() las 5 medidas de posición que resumen y caracterizan a la distribución, menos sensibles a \emph{outliers} que la media, la varianza y la desviación típica, al ordenarse los proyectos de menor a mayor puntuación. La representación conjunta de las distintas habilidades en el mismo gráfico() nos da una primera aproximación a las posibles relaciones que se establecen entre ellas. Son el valor mínimo y máximo que determinan el dominio de la variable y los cuartiles.

\section{EDA: correlaciones de las dimensiones CT} 
\label{sec:EDA_corr}

Con el objetivo de establecer el grado de dependencia existente entre la puntuación total con cada una de las variables o habilidades que la conforman, entre estas habilidades entre sí y la evolución de estas asociaciones según aumenta la puntuación total, se calcula el coeficiente de correlación de Pearson, definido en la ecuación~\ref{eq:correlacion}. % ¿Meto formula y explicación aquí?

Primero se recurre al método \texttt{corrwith()} del objeto \texttt{df\_ct} para determinar cómo aumenta la puntuación total según se incrementa cada variable del pensamiento computacional. Devuelve un objeto de tipo serie que nos ayuda a identificar qué habilidades presentan menores interdependencias lineales con el total resultante de la agregación de sus valores.

A continuación se obtiene la matriz simétrica con los coeficientes de correlación de Pearson entre cada par de capacidades. Se aplica el método corr() sobre \texttt{df\_ct} y se representa la matriz mediante un mapa de calor que resalta las habilidades con relaciones positivas más fuertes. Así se puede comprobar si las capacidades que conceptualmente se desarrollan juntas, como sincronización y paralelismo o control de flujo y pensamiento lógico, realmente muestran esa dependencia en las poblaciones de  proyectos de Scratch y Snap! analizadas.

\begin{figure}[H]
    \centering
    \includegraphics[height=.5\textheight]{img/diagrama_corr2.png}
    \caption{Diagrama de flujo de df\_correlation\_bar\_chart(score, ct)}\label{fig:diagrama_corr}
\end{figure}

%Para mostrar las dependencias lineales que se van produciendo según aumenta la complejidad de los proyectos, se sigue el algoritmo representado en el diagrama~\ref{fig:diagrama_corr}. Se almacenan en la lista \texttt{total\_score} las distintas puntuaciones totales de los proyectos, tomadas de la columna \emph{Total} del dataframe. Se crea un objeto de tipo GroupBy() que divide los proyectos en grupos separados por puntuación total. Se guarda en otra lista los nombres de las variables o características del dataframe \texttt{df\_ct}. Para cada puntuación total desde 0 hasta 21, se llama a \texttt{df\_distrib\_score()}, que obtiene el grupo de proyectos con la puntuación total pasada como parámetro, filtrado para cada dimensión del CT. Se aplica un recuento de los proyectos que consiguen 0, 1, 2 o 3 puntos en cada habilidad para representar su distribución. Se comprueba que la puntuación total no valga 0 o 21, en cuyo caso no tiene sentido calcular la matriz de correlación, pues no existe variación conjunta de cada par de variables con respecto a su media, ni de cada una de ellas por separado, siendo su cociente indeterminado. Se calcula y representa la matriz de correlación, si la puntuación total es válida.

Para mostrar las dependencias lineales que se van produciendo según aumenta la complejidad de los proyectos, se sigue el algoritmo representado en el diagrama~\ref{fig:diagrama_corr}. Recibe como parámetros de entrada dos listas, \texttt{total\_score}, con las puntuaciones totales únicas y ordenadas conseguidas por los proyectos, y \texttt{ct}, con las variables o atributos de \texttt{df\_ct}. Se encarga de obtener un dataframe con el grupo de proyectos para cada puntuación total, filtrarlos y devolver la distribución de puntuaciones para cada habilidad. Comprueba que el grupo de proyectos no sea el de las puntuaciones totales extremas, puesto que en ellos la media coincide con la valoración obtenida por cada proyecto para cada dimensión, no existiendo variación conjunta entre cada par de habilidades o covarianza, ni en cada una por separado o desviación típica. Su razón, que es la correlación, tampoco existe. Si la puntuación es válida, calcula y representa la matriz de correlación del grupo. Se repite el proceso para cada puntuación total. 

\section{Rutas de aprendizaje con proyectos representativos}  
\label{sec:rutas_diseño}

Para poder responder a cómo es el proceso de aprendizaje empírico que se manifiesta al analizar las extensas poblaciones de proyectos de Scratch y Snap! se plantea el diagrama~\ref{fig:diagrama_rutas}. 

En este caso no estamos interesados en segmentar los proyectos en k grupos aplicando el algoritmo K-Means directamente. El criterio elegido para su partición es la puntuación total que obtienen. El objeto devuelto por groupby() agrupa los proyectos de nuestro dataset en función de su puntuación total. K-Means toma el grupo de una puntuación con k=1 y se ejecuta iterativamente hasta que el centroide o centro se sitúa en el punto medio que minimiza la suma de las distancias euclídeas de cada proyecto del grupo a este centro. Cuando el algoritmo converge, se calcula cuál es el proyecto más cercano a este centroide, expresado como un vector de características cuyas coordenadas son las 7 dimensiones del pensamiento computacional que mejor caracterizan al grupo. Se repite el proceso para cada grupo definido por su puntuación total.

Una vez se ha obtenido el proyecto representativo de cada puntuación total, se concatenan los dataframes de una fila, en los que se ha representado cada vector, en una única tabla \texttt{learning\_by\_total}, a la que se añade la variable total. Se representan los prototipos de cada puntuación total, para visualizar la mejora de qué habilidad nos permite pasar a la siguiente puntuación y qué valores recibe cada capacidad en cada nivel de complejidad. Los resultados se recogen en los diagramas de barras~\ref{fig:path_Scratch} y~\ref{fig:path_Snap}.

\begin{figure}[H]
    \centering
    \includegraphics[height=.45\textheight]{img/ruta_de_aprendizajeCaja.png}
    \caption{Diagrama de flujo de get\_df\_representative(df, n), incluido en la obtención de las rutas de aprendizaje.}\label{fig:diagrama_rutas}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% EXPERIMENTOS Y VALIDACIÓN %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Experimentos y validación}

Este capítulo se introdujo como requisito en 2019. 
Describe los experimentos y casos de test que tuviste que implementar para validar tus resultados. 
Incluye también los resultados de validación que permiten afirmar que tus resultados son correctos. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% RESULTADOS %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Resultados}

% Motivación
Se filtran y agrupan los datos para realizar cálculos estadísticos y matemáticos que nos permitan descubrir y visualizar información contenida en los mismos empleando las bibliotecas de pandas, matplotlib y seaborn para ver qué habilidades del PC se desarrollan con mayor facilidad, cuáles resultan más complejas, ver si existen relaciones entre ellas, cuál es el camino de aprendizaje empírico demostrado a partir de un volumen de proyectos suficientemente amplio y representativo del conjunto de proyectos de Scratch y Snap! Comparándolos se puede ver si los desarrolladores de los proyectos siguen las mismas pautas o por el contrario tienen más facilidad para desarrollar un conjunto de capacidades distintas, puesto que se parte de la base de que los programadores de proyectos de Snap! ya tienen ciertos conocimientos tanto en programación como en el proceso cognitivo que la sustenta.

\section{Análisis de datos de proyectos de Scratch} 
\label{sec:result_scratch}

\subsection{Extracción y limpieza de datos}
\label{subsec:clean_data_Scratch}

A partir del proceso de extracción y recolección de datos de los 269844 proyectos de Scratch desde el servidor de Dr. Scratch en un fichero llamado \emph{results.csv}, se obtiene un dataset de partida con tantas observaciones como proyectos y 11 variables, atributos o características. Estas variables incluyen el nombre único del proyecto de Scratch, las puntuaciones discretas en el rango [0, 3] conseguidas para cada una de las 7 dimensiones del pensamiento computacional, la suma y el valor medio de las mismas, asignadas a las características total y media y el nivel básico, desarrollador o profesional. En la figura~\ref{fig:df_Scratch} se muestra la estructura de datos bidimensional de los diez primeros proyectos y los valores en bruto de los datos para las características mencionadas. 

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{img/df_origen_Scratch.png}
    \caption{Dataframe de los proyectos de Scratch obtenido al cargar \emph{results.csv}}\label{fig:df_Scratch}
\end{figure}

Se comprueba que no existen proyectos de Scratch duplicados y se eliminan áquellos cuyas variables no tienen valores asignados. Como resultado se obtiene un dataset con 269842 proyectos. Se ajustan los tipos de las variables a discretas para las puntuaciones de cada dimensión y para la total, y de tipo categórico ordinal para los tres niveles que pueden alcanzar los proyectos de Scratch en función de su puntuación total: \emph{ básico o ``basic''} de 0 a 7 puntos, \emph{desarrollador o ``developing''} de 8 a 14 puntos y \emph{profesional o ``proficiency''} de 15 a 21 puntos. 
% Básico, en desarrollo y completo

\subsection{Análisis de los proyectos de Scratch por nivel o categoría asignada y puntuación total. Distribución de frecuencias}
\label{subsec:frec_nivel}

% Etapa de desarrollo del PC
Tras el preprocesamiento y limpieza de datos, se continúa con el análisis exploratorio de datos, en el que se responde a ¿cómo es la distribución de los proyectos de Scratch por nivel? 

% Proporción y comparaciones entre partes de un todo. Histograma para intervalos continuos, donde hay gaps o valores inusuales -> outliers
En los diagramas de barras y de sectores de la figura~\ref{fig:level_Scratch} se clasifican los proyectos de Scratch según la etapa de desarrollo en que se encuentren. La categoría ``\emph{basic}'' es la más frecuente pues agrupa 131007 proyectos que constituyen un 48,55\% del conjunto total. El siguiente nivel más frecuente es el intermedio o ``\emph{developing}'' con un 38,59\% del dataset completo, que se corresponde con 104142 proyectos. Únicamente 34689 proyectos de Scratch, un 12,86\% del total, alcanzan el nivel avanzado o ``\emph{proficiency}''. Aproximadamente la mitad de los proyectos de Scratch analizados son muy sencillos y no consiguen puntuar por encima de los 7 puntos totales. En contraste solo un 12,86\% demuestran un dominio del pensamiento computacional superior a los 14 puntos.

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{img/freq_level_Scratch.png}
    \caption{Distribución de proyectos de Scratch por nivel asignado}\label{fig:level_Scratch}
\end{figure}

¿Cómo se distribuyen los proyectos de Scratch entre las distintas puntuaciones asignadas a cada nivel?

Para la categoría \emph{basic} representada en la figura~\ref{fig:basic} se aprecia una tendencia ascendente en la puntuación conseguida, con un máximo en los 7 puntos. Si bien es importante remarcar que 16189 proyectos no consiguen puntuar por estar incompletos.

Sin embargo en la categoría intermedia o \emph{developing}, se sigue una tendencia descendente, como se observa en la figura~\ref{fig:developing}.

En la categoría de nivel avanzado o \emph{proficiency} se continúa con una tendencia descendente hasta los 18 puntos. Se eleva a 5570 la cantidad de proyectos con 19 puntos, para disminuir notablemente en los 21 puntos totales (véase figura~\ref{fig:proficiency}). Únicamente 180 proyectos obtienen la calificación máxima en cada una de las siete dimensiones del pensamiento computacional. 

\begin{figure}[H]
    \centering
    \begin{subfigure}[h]{.75\textwidth} 
        \includegraphics[width=\textwidth]{img/basic_Scratch}
        \caption{Nivel básico}
        \label{fig:basic}
    \end{subfigure}       
    \begin{subfigure}[h]{.75\textwidth} 
        \includegraphics[width=\textwidth]{img/developing_Scratch}
        \caption{Nivel intermedio}
        \label{fig:developing}
    \end{subfigure}
    \begin{subfigure}[h]{.75\textwidth} 
        \includegraphics[width=\textwidth]{img/proficiency_Scratch}
        \caption{Nivel avanzado}
        \label{fig:proficiency}
    \end{subfigure}
    \caption{Distribución de proyectos de Scratch por puntuaciones asignadas a cada nivel}
\end{figure}

En la tabla~\ref{table:mean_Scratch} se indican las medidas de tendencia central y de dispersión para cada nivel. En el nivel \emph{basic}, al ser la media menor que la mediana, la distribución tiene una asimetría negativa o hacia la izquierda. En los niveles \emph{developing} y \emph{proficiency} la asimetría es positiva o hacia la derecha, puesto que la media supera a la mediana, aunque en los gráficos de distribución no es tan evidente. La dispersión de los valores de la puntuación con respecto a la media disminuye según aumenta el nivel, aunque se mantienen valores elevados de desviación típica para todos ellos, implicando que la mediana será más representativa que la media.

\begin{table}[htbp]
 \begin{center}
  \begin{tabular}{|c|c|c|c|c|}
    \hline
     \textbf{Nivel} & \textbf{Media} & \textbf{Mediana} & \textbf{Varianza} & \textbf{Desviación típica} \\ \hline
    \textbf{Basic} & 4.634554 & 5 & 5.100514 & 2.258432 \\ \hline
    \textbf{Developing} & 10.535164 & 10 & 3.755300 &  1.937860 \\ \hline
    \textbf{Proficiency} & 17.198426 & 17 & 3.137785 &  1.771379 \\ \hline
  \end{tabular}
  \caption{Medidas de tendencia central y dispersión para cada nivel de Scratch.}
  \label{table:mean_Scratch}
 \end{center}
\end{table}

¿Cómo se distribuyen los proyectos de Scratch según la puntuación total?

Cómo se percibe en la figura~\ref{fig:total_Scratch}, se produce una elevada concentración de proyectos entre los 4 y los 11 puntos, con un máximo en los 7 puntos. La cantidad de proyectos que consiguen cada puntuación crece rápidamente hasta esta puntuación más frecuente o moda. A partir de la misma disminuye de manera más suave, obteniendo una cola que se extiende hacia la derecha según la valoración total del proyecto toma los valores más altos.

\begin{figure}[H]
    \centering
    \includegraphics[width=.9
    \textwidth]{img/frequency_total_score_Scratch.png}
    \caption{Distribución de proyectos de Scratch por puntuación total}\label{fig:total_Scratch}
\end{figure}

% Es normal que haya gran cantidad de proyectos de nivel basic puesto que los alumnos se inician en la programación y en el desarrollo de su pensamiento computacional con proyectos sencillos, para luego ir incrementando su complejidad, viéndose motivados por la realimentación que proporciona Dr. Scratch para mejorar en cada área y evitar malas prácticas. 
Parece razonable que aproximadamente la mitad de los proyectos se encuentren en un nivel básico con puntuaciones totales bajas, puesto que el público objetivo son alumnos que se inician en la programación y en el desarrollo de su pensamiento computacional con proyectos sencillos codificados en Scratch. La finalidad es que los alumnos incrementen la  complejidad de sus proyectos, al verse motivados por la realimentación que proporciona Dr. Scratch para mejorar en cada dimensión del pensamiento computacional y evitar malos hábitos al programar. La cantidad de proyectos que superen el umbral de los 7 puntos debería incrementarse para ascender a las categorías superiores. No obstante resulta complicado implementar proyectos que contengan todos los conceptos y prácticas computacionales de mayor valoración en cada dimensión.

\subsection{Frecuencia de los proyectos de Scratch por áreas del pensamiento computacional}
\label{subsec:frec_pc_Scratch}

¿Cuál es la distribución de la puntuación en cada dimensión?

% **Referenciar a la tabla estado del arte dr. Scratch
Se filtran y agrupan los proyectos según las métricas establecidas en Dr. Scratch para cada destreza del pensamiento computacional.

\begin{figure}[H]
    \centering      
    \begin{subfigure}[h]{1\textwidth} 
        \includegraphics[width=\textwidth]{img/df_PC_Scratch.png}
        \caption{Dataframe con la cantidad de proyectos por puntuación y dimensión del PC}
        \label{fig:df_PC_Scratch}
    \end{subfigure}
    \begin{subfigure}[h]{1\textwidth} 
        \includegraphics[width=\textwidth]{img/distribution_PC.png}
        \caption{Diagrama de barras con la cantidad de proyectos por puntuación y dimensión del PC}
        \label{fig:barras_PC_Scratch}
    \end{subfigure} 
\caption{Distribución de proyectos de Scratch por puntuación para cada dimensión del PC}
\end{figure}

\begin{itemize}
    
    \item \textbf{Abstracción}: Es la capacidad menos desarrollada. Se utiliza más de un script y más de un personaje u objeto en 40694 proyectos, estando evaluados con 1 punto. Los 3 puntos asignados por el uso de clones tienen una frecuencia absoluta similar, con 39438 proyectos. Únicamente 18193 proyectos tienen bloques o funciones definidas por el programador. Un total de 171517 proyectos carecen de estos elementos vinculados con la descomposición del problema en partes más sencillas que puedan ser reutilizadas tras extraer lo relevante de cada parte, descubrir patrones y generalizar.
    
    \item \textbf{Paralelismo}: La puntuación de 2 puntos destaca sobre las demás, con 149334 proyectos que cuentan con flujos de código que se ejecutan simultáneamente al pulsar sobre una tecla o sobre un objeto.
    
    \item \textbf{Pensamiento lógico}: En 100164 proyectos del dataset no se emplean estructuras condicionales que seleccionen las instrucciones a realizar en función de que se cumpla una condición. Un conjunto de 67120 proyectos cuentan con al menos un if, 51955 con un if-else y 50593 emplean operadores lógicos, disminuyendo la frecuencia según aumenta la complejidad.
    
    \item \textbf{Sincronización}: En 156004 proyectos se emplean bloques de espera para establecer el orden en que los programas de un proyecto se ejecutan, haciendo que interactúen entre sí, consiguiendo por ello 1 punto. Elementos como el intercambio de mensajes o establecer eventos de parada solo se utilizan en 17613 proyectos evaluados con 2 puntos. Aumenta la frecuencia de los que son valorados con 3 puntos por emplear eventos como el cambio de escenario o el resultado de la ejecución de otro programa para que se continúe con la ejecución de las sentencias sujetas a que se produzcan estos eventos.
    
    \item \textbf{Control de flujo}: En más de la mitad de los proyectos, en concreto en 148270, se demuestran nociones algorítmicas al secuenciar las instrucciones de manera concreta y precisa. Por ello obtienen un punto. La distribución se reduce linealmente, de modo que 68488 proyectos emplean bucles infinitos o que iteran un nº concreto de veces. Las estructuras iterativas sujetas a condiciones están presentes en 11695 proyectos, que reciben 3 puntos.
   
    % Videojuegos en cuenta los eventos que introduce el usuario en el programa
    \item \textbf{Interactividad con el usuario}: Se evalúa la gestión de las acciones que el usuario realiza sobre el programa cuando mueve el ratón, pulsa sobre los objetos, presiona teclas del teclado o responde a preguntas con 2 puntos, alcanzados en 141303 proyectos. La siguiente valoración más frecuente es 1 punto, con 106593 proyectos que solo cuentan con la bandera verde como elemento interactivo que desencadena la ejecución de los programas.
    
    \item \textbf{Representación de la información}: Se modifican los atributos de los objetos o personajes en 90751 proyectos, que obtienen un punto. Llama la atención la escasez de proyectos que consiguen 2 puntos por inicializar y modificar variables para almacenar los datos que requieren los programas, frente a los 56258 que utilizan listas y sus métodos, siendo calificados con la máxima puntuación. % como contenedores de múltiples datos de diferente tipo
    
\end{itemize}

\subsection{Análisis estadístico general de las dimensiones del pensamiento \\computacional con Scratch}
\label{subsec:estad_pc_Scratch}

% Estos resultados guardan consonancia con lo que se refleja en la figura~\ref{fig:barras_PC_Scratch}.
Se complementa el análisis univariante calculando los estadísticos descriptivos más básicos para cada capacidad que se muestran en la figura~\ref{fig:describe_Scratch}. A partir del valor medio y de la medida de posición del segundo cuartil, que coincide con la mediana, se infiere que las habilidades más desarrolladas son paralelismo e interactividad con el usuario, mientras que abstracción es la que resulta más compleja. Su dispersión en torno a la media es una de las más altas, junto a la que se produce en representación de los datos y pensamiento lógico. El 75\% de los proyectos son valorados con 0 o 1 puntos en abstracción y sincronización, mientras que para el resto de dimensiones algunos de ellos alcanzan los 2 puntos. 

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{img/describe_Scratch.png}
    \caption{Media, desviación estándar y cuartiles de cada CT}
    \label{fig:describe_Scratch}
\end{figure}

A continuación se representa en la figura~\ref{fig:cajas_Scratch} la concentración de las puntuaciones de cada habilidad del PC en base a la mediana y a los cuartiles y se comprueba si existen valores atípicos.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{img/diag_cajas_Scratch2.png}
    \caption{Diagrama de cajas de cada dimensión del CT}
    \label{fig:cajas_Scratch}
\end{figure}

\begin{itemize}
    \item \textbf{Abstracción y sincronización}: Al ordenar los proyectos de menor a mayor puntuación más de la mitad no puntúan en abstracción. Por lo tanto el primer cuartil $(Q_1)$ y la mediana están situados en 0. En el tercer cuartil $(Q_3)$ algunos proyectos consiguen 1 punto. En sincronización la mediana coincide con el tercer cuartil en 1 punto. En ambos el 75\% de los proyectos están entre 0 y 1 puntos, el límite superior se localiza en los 2 puntos y los proyectos con 3 puntos serían \emph{outliers} o valores atípicos, pero válidos en este estudio, ya que hay más proyectos con 3 puntos que con 2 puntos, como se veía en la  figura~\ref{fig:df_PC_Scratch}.
    \item \textbf{Paralelismo, interactividad con el usuario y control de flujo}: Sus diagramas de cajas son similares y las distribuciones son más simétricas. Los proyectos alcanzan 1 punto en el primer cuartil y 2 puntos en el tercer cuartil. La mediana de paralelismo e interactividad con el usuario coincide con el tercer cuartil y se corresponde con los 2 puntos. En cambio, para control de flujo la mediana coincide con el primer cuartil en 1 punto. El límite superior para las tres está en 3 puntos. Todo ello indica que las puntuaciones están más concentradas en 1 y 2 puntos, con mayor cantidad de proyectos en el cuartil que coincide con la mediana.
    \item\textbf{Pensamiento lógico y representación de los datos}: También siguen una dispersión similar, con un rango intercuartil de 0 a 2 puntos y la mediana en 1 punto. Sus valores están más dispersos que en las otras dimensiones. El límite superior está en 3 puntos. 
\end{itemize}

Siguiendo con el análisis exploratorio de datos o EDA se calculan los coeficientes de correlación de Pearson existentes entre la puntuación total y las distintas habilidades, para determinar si existe una dependencia lineal perfecta o próxima a 1.% y el aporte de cada una. función lineal que una la variable x con la variable Y


\begin{table}[htbp]
 \begin{center}
 \resizebox{15cm}{!} {
    \begin{tabular}{|c|c|c|c|c|c|c|c|}
    \hline
    \textbf{Correlación} & \textbf{Abstracción} & \textbf{Paralelismo} & \textbf{Lógica} & \textbf{Sincronización} & \textbf{Control de flujo} & \textbf{\begin{tabular}[c]{@{}c@{}}Interactividad\\ con el usuario\end{tabular}} & \textbf{\begin{tabular}[c]{@{}c@{}}Representación\\ de los datos\end{tabular}} \\
    \hline
    \textbf{Total} & 0.772359 & 0.720550 &  0.787795 & 0.753190 & 0.772396 & 0.609517 &  0.786001 \\
    \hline
    \end{tabular} }
    \caption{Correlación de la puntuación total con cada dimensión del PC}
    \label{table:corr_total_Scratch}
 \end{center}
\end{table}

De la tabla~\ref{table:corr_total_Scratch} se deduce que las correlaciones son directas y fuertes entre la puntuación total y cada dimensión del pensamiento computacional, al ser superiores a 0.7,
%$\rho>0.7$**, 
salvo en interactividad con el usuario, que sería la habilidad que menos aporta a la puntuación total y la que más información contiene. Cuando aumenta la puntuación de interactividad se incrementa la puntuación total en menor medida que si crecen las valoraciones de las otras dimensiones.
    
El siguiente paso es indagar si existen relaciones entre las dimensiones del pensamiento computacional o si por el contrario son todas independientes linealmente entre sí. Para ello se realiza un análisis multivariante, calculando la correlación de Pearson para cada par de características o dimensiones. % Si dos de ellas son dependientes se podrían agrupar  % Herramienta fundamental del EDA

\begin{figure}[H]
    \centering
    \includegraphics[width=.7\textwidth]{img/corr_Scratch.png}
    \caption{Matriz de correlación de Pearson de las dimensiones del PC.}\label{fig:corr_Scratch}
\end{figure}

Se producen correlaciones positivas débiles y moderadas entre cada par de dimensiones. Las más bajas ocurren entre interactividad con el usuario con cada una de las siguientes: lógica, sincronización y representación de la información. Existe escasa dependencia entre implementar código que se encargue de las acciones que realice el usuario sobre el programa con determinar las sentencias que se ejecutan en función de condiciones, con la organización de la ejecución de los distintos programas de manera que interactúen entre sí y con la declaración y la modificación de los datos sobre los que se opera en los programas.

Los mayores coeficientes de correlación, que se corresponden con una correlación positiva moderada, se obtienen entre:

\begin{itemize}
    \item \textbf{Lógica y representación de los datos}: Cuando se codifican estructuras algorítmicas selectivas, planteando las condiciones que determinan por dónde continúa el flujo del programa, también aumenta la habilidad para definir y manipular los datos de variables, listas y atributos que necesitan los personajes y programas para su ejecución.
    \item \textbf{Abstracción y control de flujo}: La destreza mostrada al descomponer en partes el problema a resolver con funciones y procedimientos encargados de tareas concretas e instanciando objetos o clones cuando se requiera que hagan las mismas instrucciones, guarda relación con las nociones algorítmicas demostradas en cada una de esas partes ya sea secuenciando instrucciones o empleando bucles. %%
    \item \textbf{Paralelismo y control de flujo}: La capacidad de dividir el problema en programas que son ejecutados a la vez por uno o varios personajes depende linealmente de que los algoritmos que sustentan dichos programas estén definidos de manera precisa y ordenada y utilicen bucles cuando sea recomendable.
    \item \textbf{Sincronización y representación de los datos}: Establecer el orden en que se ejecutan los distintos programas para que interactúen entre sí se relaciona con declarar y modificar las variables, listas y atributos que contienen los datos requeridos en todos ellos.
\end{itemize}


\subsection{Frecuencias y correlaciones de las dimensiones del PC en función de la puntuación total para proyectos de Scratch}
\label{subsec:corr_21_Scratch}

Se profundiza en el análisis multivariante comprobando las dependencias lineales entre cada par de dimensiones del pensamiento computacional según aumenta la puntuación total. Para ello se observa la evolución de la matriz de correlación de Pearson y de las distribuciones de puntuación en cada dimensión. El objetivo es tratar de esclarecer cuáles son las dimensiones que se desarrollan antes, qué puntuaciones se les van asignando y qué relaciones se establecen entre ellas según aumenta la complejidad de los proyectos, determinada por la puntuación total.

En los casos extremos, cuando la puntuación total es de 0 y 21, todas las dimensiones tienen asignadas las mismas puntuaciones en cada proyecto, 0 y 3 respectivamente. No hay dispersión con respecto a la media, tanto al tomar cada variable o dimensión por separado como al analizar la variación conjunta de cada par de variables. Por lo tanto la covarianza y la raíz de la varianza o desviación típica son nulas y su razón, que conforma el coeficiente de correlación, indeterminada (véase la ecuación~\eqref{eq:correlacion}). % variación conjunta con respecto a las medias

\begin{equation}
   \rho_{xy} = \dfrac{Cov(X,Y)}{\sigma_{x}\sigma_{y}} = \dfrac{\sum_{i=1}^{n} (x_i - \overline{x})(y_i - \overline{y})}{\sqrt{\sum_{i=1}^{n} (x_i - \overline{x})^{2}}\sqrt{\sum_{i=1}^{n} (y_i - \overline{y})^{2}}},  siendo: -1<\rho_{xy}<1
   \label{eq:correlacion}
\end{equation}   

Se prosigue con el desglose de las puntuaciones conseguidas en cada habilidad para cada puntuación total, según progresa de 1 a 20 y se analizan las dependencias que surgen entre ellas.

Si la puntuación total es 1 aumenta paralelismo e interactividad con el usuario, y en menor medida control de flujo y sincronización, según vemos en el diagrama de barras~\ref{fig:total1}. Las dos primeras son las capacidades que se desarrollan cuando los programadores comienzan a utilizar  Scratch. Al repartirse el punto entre varias dimensiones,
la matriz de correlación~\ref{fig:corr1} muestra una correlación perfecta positiva para cada par de dimensiones del pensamiento computacional.

\begin{figure}
    \centering
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/distribucion_1_Scratch}
        \caption{Diagrama de barras. Total=1}
        \label{fig:total1}
    \end{subfigure}       
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/corr_1_Scratch}
        \caption{Matriz de correlación. Total=1}
        \label{fig:corr1}
    \end{subfigure}
     \caption{Distribución de puntuaciones asignadas y correlación entre dimensiones del PC cuando la puntuación total vale 1}
\end{figure}

\begin{figure}[H]
    \centering
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/distribucion_2_Scratch}
        \caption{Diagrama de barras. Total=2}
        \label{fig:total2}
    \end{subfigure}       
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/corr_2_Scratch}
        \caption{Matriz de correlación. Total=2}
        \label{fig:corr2}
    \end{subfigure}
     \caption{Distribución de puntuaciones asignadas y correlación entre dimensiones del PC cuando la puntuación total vale 2}
\end{figure}

Como se percibe en la figura~\ref{fig:total2} la mayor parte de los proyectos cuentan con 1 punto en paralelismo y en interactividad con el usuario, que agregados conforman el total de 2.

De la matriz de correlación de la figura~\ref{fig:corr2} se deduce que aquellos pares de variables en los que la correlación no es perfecta y positiva, tienen una correlación débil y negativa. Entre paralelismo e interactividad con el usuario se produce una dependencia lineal perfecta, ya que cuando el usuario pulsa la bandera verde se desencadena la ejecución de varios flujos de código simultáneamente. Estas dos dimensiones se relacionan en sentido inverso con las otras aptitudes. El resto de dimensiones mantienen entre sí una relación perfecta positiva porque no puntúan. 

\begin{figure}[H]
    \centering
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/distribucion_3_Scratch}
        \caption{Diagrama de barras. Total=3}
        \label{fig:total3}
    \end{subfigure}       
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/corr_3_Scratch}
        \caption{Matriz de correlación. Total=3}
        \label{fig:corr3}
    \end{subfigure}
     \caption{Distribución de puntuaciones asignadas y correlación entre dimensiones del PC cuando la puntuación total vale 3}
\end{figure}

En la figura~\ref{fig:total3} se observa que los proyectos completan los 3 puntos totales con 1 o 2 puntos en paralelismo, 1 punto en interactividad con el usuario o incluso 1 punto en control de flujo, puesto que la frecuencia de ocurrencia es superior a 4000.

Persisten las dependencias lineales positivas perfectas, con $\rho=1$, entre las capacidades con valoración nula, como se constata en la figura~\ref{fig:corr3}. Entre paralelismo e interactividad con el usuario hay una correlación positiva alta, igual que entre control de flujo y lógica y entre control de flujo y sincronización. No hay dependencia lineal entre control de flujo y paralelismo. Hay una correlación negativa moderada entre paralelismo con: representación de los datos, abstracción, lógica o sincronización. Es extraño que según aumenta una de las variables disminuya la otra, ya que el aumento en la capacidad para realizar tareas simultáneamente, no tiene por qué disminuir a la capacidad para establecer los atributos de los distintos objetos del proyecto o la habilidad para subdividir el problema en partes o ser capaz de establecer las condiciones que determinan la ejecución de unas acciones u otras. El hecho de que según aumenta paralelismo disminuya sincronización es bastante contradictorio, pues si se realizan tareas simultáneas debe existir alguna forma de que ajusten su ejecución en el tiempo.

En el diagrama de barras~\ref{fig:total4} se ve que en abstracción, lógica, sincronización y representación de los datos se siguen obteniendo 0 puntos en la mayoría de los proyectos. Sin embargo, se incrementan los que consiguen 1 punto en lógica, en sincronización y en control de flujo.

En la matriz de correlación~\ref{fig:corr4} queda patente que existe dependencia lineal casi perfecta entre las dimensiones cuya puntuación más frecuente es 0 puntos. Cuando se codifican programas interactivos aumentan las nociones algorítmicas, como se deduce de la elevada relación lineal directa entre interactividad con el usuario y control de flujo. No existe dependencia lineal entre representación de los datos y control de flujo, ni entre este último y abstracción. Existe una correlación negativa moderada entre paralelismo y abstracción. El aumento de la valoración en una de las habilidades no debería hacer disminuir la otra. De hecho, la descomposición del programa en subprogramas encargados de tareas concretas podría facilitar la ejecución simultánea de varios subprogramas. También se da este tipo de correlación negativa entre paralelismo y representación de los datos.%%

\begin{figure}[H]
    \centering
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/distribucion_4_Scratch}
        \caption{Diagrama de barras. Total=4}
        \label{fig:total4}
    \end{subfigure}       
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/corr_4_Scratch}
        \caption{Matriz de correlación. Total=4}
        \label{fig:corr4}
    \end{subfigure}
     \caption{Distribución de puntuaciones asignadas y correlación entre dimensiones del PC cuando la puntuación total vale 4}
\end{figure}


Según el diagrama de barras~\ref{fig:total5} correspondiente a la puntuación total de 5, paralelismo e interactividad con el usuario son las capacidades mejor valoradas, puesto que la mitad de los proyectos consiguen 2 puntos. También aumenta la cantidad de proyectos que consiguen 1 punto en lógica y sincronización.

Al aumentar las puntuaciones, hay menos pares de dimensiones con coeficiente de correlación perfecto. Las máximas correlaciones en sentido positivo se producen entre paralelismo e interactividad con el usuario, y en menor medida entre representación de los datos y abstracción, entre sincronización y lógica y entre representación de los datos y lógica, como se observa en la figura~\ref{fig:corr5}. Resulta llamativo que no exista correlación entre sincronización y paralelismo, ya que si se ejecutan varios conjuntos de bloques a la vez tiene que existir algún evento que sincronice los procesos de manera que se comuniquen entre sí. Vuelve a aparecer una correlación moderada en sentido negativo entre paralelismo y abstracción con el mismo coeficiente que en la puntuación total de 4 puntos. También se obtiene una correlación de este tipo entre interactividad con el usuario y abstracción.%%

\begin{figure}[H]
    \centering
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/distribucion_5_Scratch}
        \caption{Diagrama de barras. Total=5}
        \label{fig:total5}
    \end{subfigure}       
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/corr_5_Scratch}
        \caption{Matriz de correlación. Total=5}
        \label{fig:corr5}
    \end{subfigure}
     \caption{Distribución de puntuaciones asignadas y correlación entre dimensiones del PC cuando la puntuación total vale 5}
\end{figure}

Según se distingue en el diagrama de barras~\ref{fig:total6} correspondiente a la puntuación total de 6, se eleva la cantidad de proyectos con 1 punto en sincronización, control de flujo, interactividad con el usuario y representación de los datos.

Paralelismo y abstracción obtienen una correlación moderada en sentido negativo similar a la puntuación anterior. No hay correlación entre abstracción y sincronización, ni entre paralelismo y representación de los datos. Las mayores correlaciones se obtienen entre: control de flujo y sincronización, de modo que la secuenciación precisa, concreta y ordenada de instrucciones o bloques afecta a la organización temporal de los distintos flujos de código para que interactúen entre sí; entre lógica y representación de los datos, ya que tener una alta capacidad para buscar la solución al problema e implementar distintas acciones en función de condiciones, influye en almacenar en atributos y variables los datos tanto de condiciones como de resultados. Entre paralelismo e interactividad con el usuario existe una alta  dependencia ya que el usuario puede pulsar sobre una tecla u objeto provocando la ejecución simultánea de varias secuencias de bloques.%%

\begin{figure}[H]
    \centering
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/distribucion_6_Scratch}
        \caption{Diagrama de barras. Total=6}
        \label{fig:total6}
    \end{subfigure}       
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/corr_6_Scratch}
        \caption{Matriz de correlación. Total=6}
        \label{fig:corr6}
    \end{subfigure}
     \caption{Distribución de puntuaciones asignadas y correlación entre dimensiones del PC cuando la puntuación total vale 6}
\end{figure}

Para la puntuación total de 7, lo más destacable en la representación de frecuencias de la figura~\ref{fig:total7} es que el nº de proyectos con una puntuación de 2 en paralelismo aumenta.

\begin{figure}[H]
    \centering
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/distribucion_7_Scratch}
        \caption{Diagrama de barras. Total=7}
        \label{fig:total7}
    \end{subfigure}       
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/corr_7_Scratch}
        \caption{Matriz de correlación. Total=7}
        \label{fig:corr7}
    \end{subfigure}
     \caption{Distribución de puntuaciones asignadas y correlación entre dimensiones del PC cuando la puntuación total vale 7}
\end{figure}

La correlación es perfecta positiva entre control de flujo y sincronización y entre lógica y representación de los datos, como se visualiza en la matriz~\ref{fig:corr7}. Se alcanzan valores elevados entre lógica y sincronización, representación de los datos y sincronización, control de flujo y lógica, interactividad con el usuario y control de flujo y entre interactividad con el usuario y sincronización. Que no exista correlación entre sincronización y paralelismo resulta contradictorio, ya que si se ejecutan flujos de código a la vez debería desarrollarse la capacidad de sincronizarlos, aunque no precisamente con el bloque de espera evaluado con 1 punto. Tampoco existe correlación entre abstracción y representación de los datos, puesto que aún no se ha desarrollado la capacidad de dividir el problema en partes más simples. % hasta esta puntuación total. % Esto implica que ser capaz de codificar scripts encargados de tareas concretas que resuelvan en conjunto un problema complejo, ejecutados por los  personajes del proyecto, no influye en cómo se modifiquen sus atributos.%% modularidad y abstracción de datos 0 puntos

\begin{figure}[H]
    \centering
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/distribucion_8_Scratch}
        \caption{Diagrama de barras. Total=8}
        \label{fig:total8}
    \end{subfigure}       
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/corr_8_Scratch}
        \caption{Matriz de correlación. Total=8}
        \label{fig:corr8}
    \end{subfigure}
     \caption{Distribución de puntuaciones asignadas y correlación entre dimensiones del PC cuando la puntuación total vale 8}
\end{figure}

Cuando el total es 8, en interactividad con el usuario predominan los 2 puntos, mientras que en abstracción las puntuaciones siguen siendo bajas, como se ve en el diagrama de barras~\ref{fig:total8}.

En la matriz de correlación~\ref{fig:corr8} se obtiene de nuevo una casi perfecta correlación directa entre control de flujo y sincronización. También se consigue una correlación muy alta y en sentido positivo entre paralelismo e interactividad con el usuario, entre control de flujo y representación de los datos, entre sincronización y representación de los datos, así como entre lógica y abstracción. Sincronización y paralelismo vuelven a ser independientes linealmente. Tampoco existe correlación entre abstracción y sincronización, ni entre paralelismo y representación de los datos, de modo que la codificación de scripts para su ejecución simultánea no se ve afectada por la declaración y modificación de atributos y variables que simplifiquen el tratamiento de datos en los scripts, ni entre  interactividad con el usuario y pensamiento lógico, por lo que la implementación de distintas alternativas según se cumpla una condición no está sujeta a los eventos provocados por quién pruebe el proyecto. Se consigue de nuevo una correlación moderada en sentido negativo entre paralelismo y abstracción.% cambios de estado 

Para la puntuación total de 9, en la matriz de correlación~\ref{fig:corr9} se observan valores elevados próximos a 1, que indican correlación casi perfecta, en lógica con representación de los datos, en paralelismo con interactividad con el usuario, en control de flujo con representación de los datos y en control de flujo con sincronización. Las correlaciones entre sincronización con lógica y entre control de flujo con lógica son menores pero también elevadas. Sigue sin existir correlación entre control de flujo y abstracción, entre sincronización y abstracción, entre sincronización y paralelismo y entre lógica y paralelismo. Se vuelve además a obtener una correlación negativa moderada entre paralelismo y abstracción similar a la conseguida en puntuaciones anteriores, aún cuando se incrementa la destreza en abstracción, como se ve en el diagrama~\ref{fig:total9}.

\begin{figure}[H]
    \centering
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/distribucion_9_Scratch}
        \caption{Diagrama de barras. Total=9}
        \label{fig:total9}
    \end{subfigure}       
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/corr_9_Scratch}
        \caption{Matriz de correlación. Total=9}
        \label{fig:corr9}
    \end{subfigure}
     \caption{Distribución de puntuaciones asignadas y correlación entre dimensiones del PC cuando la puntuación total vale 9}
\end{figure}

Para la puntuación total de 10, en el diagrama de barras~\ref{fig:total10} aumenta la obtención de 2 puntos en lógica y de 3 puntos en representación de los datos, por el uso de listas. 

Existe una correlación perfecta directa entre lógica y paralelismo. Se consigue también una alta correlación positiva entre lógica e interactividad con el usuario y entre esta última y paralelismo. No hay dependencia lineal entre control de flujo y abstracción, ni entre sincronización y lógica, ni entre sincronización y paralelismo. Igual que en la puntuación anterior se obtiene una correlación moderada en sentido negativo entre abstracción y paralelismo. La capacidad de dividir el problema en partes sencillas de implementar y depurar, debería ayudar a descubrir cuáles de estas partes pueden ser ejecutadas de manera simultánea o concurrente, con una adecuada sincronización. Sin embargo el aumento de una habilidad hace que disminuya la otra. Además ambas son independientes de sincronización puesto que solo se usan bloques de espera. % Disminuye la ejecución de tareas de manera simultánea, según los datos analizados hasta ahora

\begin{figure}[H]
    \centering
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/distribucion_10_Scratch}
        \caption{Diagrama de barras. Total=10}
        \label{fig:total10}
    \end{subfigure}       
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/corr_10_Scratch}
        \caption{Matriz de correlación. Total=10}
        \label{fig:corr10}
    \end{subfigure}
     \caption{Distribución de puntuaciones asignadas y correlación entre dimensiones del PC cuando la puntuación total vale 10}
\end{figure}

\begin{figure}[H]
    \centering
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/distribucion_11_Scratch}
        \caption{Diagrama de barras. Total=11}
        \label{fig:total11}
    \end{subfigure}       
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/corr_11_Scratch}
        \caption{Matriz de correlación. Total=11}
        \label{fig:corr11}
    \end{subfigure}
     \caption{Distribución de puntuaciones asignadas y correlación entre dimensiones del PC cuando la puntuación total vale 11}
\end{figure}

Para la puntuación total de 11, en el diagrama de barras~\ref{fig:total11} destaca el aumento de proyectos que consiguen 3 puntos en pensamiento lógico.

En la matriz de correlación~\ref{fig:corr11} se observan valores elevados entre interactividad con el usuario y paralelismo, entre sincronización y representación de los datos y entre control de flujo con interactividad con el usuario. Son independientes linealmente: control de flujo y abstracción, representación de los datos y abstracción, lógica y representación de los datos, lógica y control de flujo, interactividad del usuario y representación de los datos. Vuelve a existir correlación en sentido negativo entre paralelismo y abstracción. También se da una correlación negativa prácticamente perfecta entre lógica y abstracción. Al aumentar el uso de estructuras selectivas que pueden incluir operadores lógicos, disminuye la capacidad para plantear soluciones a problemas descomponiéndolos en scripts o funciones encargadas de tareas concretas que pueden ser reutilizadas cuando se extrae lo relevante, se reconocen patrones y se generaliza. % Evolución de la programación estructurada a la modular

Para la puntuación de 12, según la matriz~\ref{fig:corr12}, existe una correlación elevada directa entre lógica y paralelismo, y entre paralelismo e interactividad con el usuario. Por ello cuando el usuario pulsa una tecla o un objeto se desencadena la ejecución de varias tareas a la vez. Se da una correlación positiva menor entre sincronización y abstracción y entre interactividad con el usuario y lógica. No hay correlación entre sincronización e interactividad con el usuario. La correlación en sentido negativo entre paralelismo y abstracción se aproxima a -1, mientras que entre lógica y abstracción es fuerte pero no perfecta, comparada con la puntuación anterior. %% Paralelismo e interactividad con el usuario cont $\rho\simeq1 $


\begin{figure}[H]
    \centering
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/distribucion_12_Scratch}
        \caption{Diagrama de barras. Total=12}
        \label{fig:total12}
    \end{subfigure}       
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/corr_12_Scratch}
        \caption{Matriz de correlación. Total=12}
        \label{fig:corr12}
    \end{subfigure}
     \caption{Distribución de puntuaciones asignadas y correlación entre dimensiones del PC cuando la puntuación total vale 12}
\end{figure}

Para la puntuación total de 13, el diagrama de barras~\ref{fig:total13} refleja un aumento en el uso de clones o instancias de los personajes creadas dinámicamente con el mismo comportamiento que el objeto inicial, como se infiere de la cantidad de proyectos con 3 puntos en abstracción.

En la matriz~\ref{fig:corr13} se obtiene una correlación positiva fuerte entre sincronización y abstracción, entre paralelismo e interactividad con el usuario, entre lógica y paralelismo %viene desde 10
y entre representación de los datos y abstracción. Al declarar atributos y listas y modificar su contenido se abstraen características de los personajes y se agrupan datos que pueden ser procesados por una misma secuencia de instrucciones o programa. No existe dependencia lineal entre interactividad del usuario con sincronización, entre control de flujo y representación de los datos, ni entre lógica y abstracción. Se recogen estos coeficientes en la figura~\ref{fig:corr13}. %La dependencia lineal inversa entre paralelismo y abstracción es más débil que en las matrices de correlación anteriores. 

\begin{figure}[H]
    \centering
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/distribucion_13_Scratch}
        \caption{Diagrama de barras. Total=13}
        \label{fig:total13}
    \end{subfigure}       
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/corr_13_Scratch}
        \caption{Matriz de correlación. Total=13}
        \label{fig:corr13}
    \end{subfigure}
     \caption{Distribución de puntuaciones asignadas y correlación entre dimensiones del PC cuando la puntuación total vale 13}
\end{figure}

Para la puntuación total de 14, en el diagrama de barras~\ref{fig:total14} la puntuación más frecuente en lógica es 3. En los proyectos que la consiguen 
se evalúan varias situaciones utilizando operadores lógicos, que permiten elegir entre distintas alternativas, obteniendo salidas diferentes.% se decide entre distintas alternativas en base a situaciones, premisas o condiciones.

\begin{figure}[H]
    \centering
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/distribucion_14_Scratch}
        \caption{Diagrama de barras. Total=14}
        \label{fig:total14}
    \end{subfigure}       
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/corr_14_Scratch}
        \caption{Matriz de correlación. Total=14}
        \label{fig:corr14}
    \end{subfigure}
     \caption{Distribución de puntuaciones asignadas y correlación entre dimensiones del PC cuando la puntuación total vale 14}
\end{figure}

En la matriz~\ref{fig:corr14} se observa una correlación positiva casi perfecta entre control de flujo e interactividad con el usuario. La dependencia lineal es elevada y positiva entre: paralelismo e interactividad con el usuario, representación de los datos con abstracción, control de flujo con paralelismo y lógica con paralelismo. Interactividad del usuario y sincronización son incorreladas, indicando que la gestión de las respuestas del usuario ante determinadas preguntas, de los movimientos con el ratón sobre objetos o de cómo responde el programa cuando se pulsa una tecla, no afecta a la capacidad del programador para planificar el orden en que se ejecutan las distintas tareas de modo que interactúen entre sí.%%

\begin{figure}[H]
    \centering
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/distribucion_15_Scratch}
        \caption{Diagrama de barras. Total=15}
        \label{fig:total15}
    \end{subfigure}       
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/corr_15_Scratch}
        \caption{Matriz de correlación. Total=15}
        \label{fig:corr15}
    \end{subfigure}
     \caption{Distribución de puntuaciones asignadas y correlación entre dimensiones del PC cuando la puntuación total vale 15}
\end{figure}

Con respecto a la puntuación total de 15, en el diagrama de barras~\ref{fig:total15} se percibe un incremento en las frecuencias correspondientes a los 3 puntos tanto en abstracción, al emplear clones, como en representación de los datos, por utilizar listas.

La matriz de correlación~\ref{fig:corr15} muestra una dependencia lineal directa perfecta entre control de flujo con interactividad con el usuario, y una correlación positiva muy elevada entre lógica y abstracción, entre representación de los datos y abstracción, entre lógica y paralelismo, entre interactividad con el usuario y paralelismo y entre control de flujo y paralelismo. Como en otras puntuaciones anteriores, sincronización e interactividad con el usuario, abstracción e interactividad con el usuario y control de flujo y sincronización están incorreladas.%%

En la puntuación total de 16 se consigue que la máxima puntuación sea la más frecuente en abstracción, \emph{lógica} y representación de los datos. En paralelismo, control de flujo e interactividad con el usuario persisten los 2 puntos, como se constata en el diagrama~\ref{fig:total16}.

Según la figura~\ref{fig:corr16} se producen elevadas dependencias en sentido positivo, ordenadas de mayor a menor, entre interactividad del usuario y control de flujo, entre lógica y paralelismo, entre abstracción y representación de los datos, entre lógica y abstracción y entre paralelismo y abstracción. La dependencia lineal de este último par ha cambiado de sentido con respecto a las 12 primeras puntuaciones totales, de manera que al aumentar la capacidad para dar modularidad al código y utilizar clones, se incrementa la habilidad de discernir qué funciones y procedimientos pueden ejecutarse simultáneamente cuando se produzca un evento. No existe correlación entre control de flujo y sincronización, ni entre interactividad del usuario y sincronización, ni entre control de flujo y abstracción, ni entre interactividad del usuario y abstracción, ni entre paralelismo y sincronización, ni entre lógica y sincronización. %@

\begin{figure}[H]
    \centering
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/distribucion_16_Scratch}
        \caption{Diagrama de barras. Total=16}
        \label{fig:total16}
    \end{subfigure}       
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/corr_16_Scratch}
        \caption{Matriz de correlación. Total=16}
        \label{fig:corr16}
    \end{subfigure}
     \caption{Distribución de puntuaciones asignadas y correlación entre dimensiones del PC cuando la puntuación total vale 16}
\end{figure}

Con respecto a la puntuación total de 17, mientras que abstracción, \emph{paralelismo}, lógica y representación de datos están prácticamente desarrolladas, control de flujo e interactividad del usuario se mantienen en los 2 puntos, como se aprecia en la figura~\ref{fig:total17}. La cantidad de proyectos de Scratch que consiguen 1 y 3 puntos en sincronización es similar.

Según se muestra en la matriz de correlación~\ref{fig:corr17}
se establecen interdependencias lineales perfectas directas entre las capacidades con 3 puntos, de manera que al descomponer en partes más sencillas el problema definiendo funciones propias o creando dinámicamente clones de los personajes, 
se ejecutan simultáneamente varios flujos de código o programas y en algunos de ellos se emplean condicionales con operadores lógicos para decidir el conjunto de instrucciones a ejecutar y cómo se modifican los datos contenidos en listas.
% se incrementa la capacidad de establecer cuáles de estas partes permiten su ejecución simultánea,
No existe dependencia lineal entre control de flujo y abstracción, entre control de flujo y sincronización, ni entre interactividad del usuario y la mayor parte de las dimensiones, salvo control de flujo, porque cuando se crean programas interactivos aumenta la capacidad de diseñar y aplicar algoritmos iterativos.

\begin{figure}[H]
    \centering
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/distribucion_17_Scratch}
        \caption{Diagrama de barras. Total=17}
        \label{fig:total17}
    \end{subfigure}       
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/corr_17_Scratch}
        \caption{Matriz de correlación. Total=17}
        \label{fig:corr17}
    \end{subfigure}
     \caption{Distribución de puntuaciones asignadas y correlación entre dimensiones del PC cuando la puntuación total vale 17}
\end{figure}

El paso de los 17 a los 18 puntos totales está marcado por el desarrollo casi completo de la sincronización, como se deduce al comparar los diagramas de barras~\ref{fig:total17} y ~\ref{fig:total18}.

\begin{figure}[H]
    \centering
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/distribucion_18_Scratch}
        \caption{Diagrama de barras. Total=18}
        \label{fig:total18}
    \end{subfigure}       
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/corr_18_Scratch}
        \caption{Matriz de correlación. Total=18}
        \label{fig:corr18}
    \end{subfigure}
     \caption{Distribución de puntuaciones asignadas y correlación entre dimensiones del PC cuando la puntuación total vale 18}
\end{figure}

Se conservan las correlaciones casi perfectas explicadas en la puntuación anterior y se añaden las que surgen entre sincronización con las otras habilidades evaluadas con 3 puntos. Por ello cuando se establece previamente el orden en que los programas serán ejecutados, de forma que interactúen y se comuniquen entre sí con mensajes, eventos o esperando el resultado de algún script, resulta más fácil que las distintas partes en que se descompone el problema puedan ejecutarse en paralelo, empleen estructuras selectivas que indiquen por donde continúa el flujo del programa y se utilicen métodos propios de listas para modificar los datos que contiene, que a su vez pueden ser usados como condiciones o eventos. Existe una correlación positiva baja entre control de flujo y lógica. Entre cada par de variables no comentadas, se puede decir que no existe correlación. Todo esto queda reflejado en la matriz~\ref{fig:corr18}.

\begin{figure}[H]
    \centering
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/distribucion_19_Scratch}
        \caption{Diagrama de barras. Total=19}
        \label{fig:total19}
    \end{subfigure}       
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/corr_19_Scratch}
        \caption{Matriz de correlación. Total=19}
        \label{fig:corr19}
    \end{subfigure}
     \caption{Distribución de puntuaciones asignadas y correlación entre dimensiones del PC cuando la puntuación total vale 19}
\end{figure}

Cuando la complejidad de los proyectos alcanza los 19 puntos, control de flujo e interactividad con el usuario siguen en 2 puntos, y el resto de dimensiones se perfilan aún más en los 3 puntos, marcando un desarrollo completo (ver figura~\ref{fig:total19}).

Debido a esta distribución de puntuaciones, las matrices de correlación~\ref{fig:corr18} y~\ref{fig:corr19} muestran las mismas correlaciones perfectas positivas. Control de flujo es independiente linealmente de las otras dimensiones, salvo de interactividad con el usuario. Interactividad con el usuario presenta correlaciones inversas bajas y moderadas con el resto  de dimensiones.

Para la puntuación total de 20, control de flujo logra alcanzar la máxima puntuación al utilizarse bucles en donde se itera hasta que se cumple una condición.

La correlación es perfecta positiva entre todas las dimensiones del pensamiento computacional, salvo para interactividad con el usuario con el resto de dimensiones, como vemos en la matriz~\ref{fig:corr20}. Esto se debe a que, según vemos en el diagrama de barras~\ref{fig:total20}, las puntuaciones de la mayor parte de los proyectos para interactividad con el usuario son de 2 puntos. Por ello su correlación es perfecta negativa con cada una de las otras áreas del PC. 

\begin{figure}[H]
    \centering
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/distribucion_20_Scratch}
        \caption{Diagrama de barras. Total=20}
        \label{fig:total20}
    \end{subfigure}       
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/corr_20_Scratch}
        \caption{Matriz de correlación. Total=20}
        \label{fig:corr20}
    \end{subfigure}
     \caption{Distribución de puntuaciones asignadas y correlación entre dimensiones del PC cuando la puntuación total vale 20}
\end{figure}

Por lo tanto la última dimensión en desarrollarse por completo es interactividad con el usuario. El cambio de los 2 a los 3 puntos se produce por implementar acciones en los personajes que respondan a las modificaciones en el audio y el vídeo que realiza el usuario para interactuar con el proyecto de Scratch, aunque en el conjunto de proyectos analizado no se aplica demasiado. Resulta llamativo que sea de las primeras habilidades en manifestarse y de las últimas en completarse, y que mantenga dependencias lineales con control de flujo desde los 10 puntos totales %
y con paralelismo hasta los 15 puntos totales. No obstante, con paralelismo comparte métricas similares, puesto que se ejecutan varios programas a la vez al pulsar sobre objetos, teclas o la bandera verde, que son acciones puntuadas con 1 y 2 en interactividad con el usuario. %%Revisar
% Las correlaciones según aumenta la puntuación total no tienen coincidencias con la correlación general de las 7 dimensiones. 
% Sincronización y paralelismo deberían mostrar dependencias.

\subsection{Aprendizaje no supervisado: clustering K-Means con los proyectos de Scratch}
\label{subsec:kmeans_Scratch}

%Para profundizar en cómo se relacionan entre sí los proyectos en función de las siete dimensiones, se buscan patrones entre los mismos que nos ayuden a descubrir similitudes entre los proyectos basados en relaciones entre las habilidades, que no han podido establecerse a partir del estudio de las correlaciones. Aplicación de un modelo de ML aunque forma parte de un EDA al tratar de descubrir más info de los proyectos\ldots
Se utiliza este algoritmo de aprendizaje no supervisado, para dividir los 269842 proyectos de Scratch en subconjuntos no solapados o particiones. Se obtienen grupos de manera que los proyectos dentro de un clúster son muy similares, y totalmente distintos a los proyectos que pertenecen a otros grupos. La semejanza o diferencia se mide en función de la distancia euclídea a un centroide del clúster, que a partir de cierto nº de iteraciones, se colocará en el centro del clúster. K-Means trata de minimizar las distancias intra-partición y maximiza las distancias inter-partición.

% Matriz de dimensión (269842, 7)
La entrada al algoritmo es un array de vectores con tantas filas como observaciones o proyectos de Scratch y cuyas componentes son las características o dimensiones del pensamiento computacional. Como cada proyecto queda representado por un punto en un espacio de 7 dimensiones cuyas coordenadas son los valores de las puntuaciones asignadas a cada habilidad, al aplicar el algoritmo K-Means, y minimizarse las distancias al punto medio o centroide de cada clúster, la cohesión del grupo determina relaciones y patrones entre las habilidades difícilmente identificables de otro modo, como en el análisis previo de las correlaciones. 

Para aplicar K-Means es necesario conocer a priori el valor de k, el nº de grupos o centroides. Una de las técnicas más extendidas para estimarlo es la curva de Elbow. Se itera sobre un conjunto de posibles valores de k buscando un cambio abrupto en la inercia, de forma que un aumento en el valor de k no suponga una disminución significativa en dicha inercia. La inercia se define como la suma de las distancias euclídeas de cada punto con respecto al centroide o centro del clúster al que pertenece, como se indica en la ecuación~\eqref{eq:inercia}. %Se establece un compromiso entre un mínimo valor de inercia y una cantidad de grupos no muy elevado.

\begin{equation}
    Inercia=WCSS=\sum \limits _{i=0}^{N} \|{x_i-c_i\|^2}
    \label{eq:inercia}
\end{equation}

\begin{figure}
    \centering
    \includegraphics[width=.6\textwidth]{img/elbow_Scratch}
    \caption{Curva de Elbow}
    \label{fig:elbow_Scratch}
\end{figure}

% En metodología o en otra parte más teórica. 
La curva de Elbow de la figura~\ref{fig:elbow_Scratch} comienza a suavizarse a partir de k=3. Se entrena el algoritmo con este valor de k. El algoritmo coloca 3 centroides de manera aleatoria y tras varias iteraciones en que se asigna cada proyecto al centroide más cercano y se recalcula la posición de este centro en función de la media de los proyectos pertenecientes al grupo, llega un momento en que el algoritmo converge. Los centroides no cambian de posición porque no se modifican los proyectos pertenecientes a cada grupo o porque se ha alcanzado el nº máximo de iteraciones. Los proyectos son etiquetados según el clúster en el que están incluidos. Cada clúster queda descrito por el proyecto más cercano a su centroide o proyecto representativo. %siendo más fácil establecer patrones.

En el artículo~\cite{moreno17:_paths} se establece un itinerario de aprendizaje en tres pasos, de complejidad incremental, basado en los proyectos representativos o prototipos de los 3 clústeres obtenidos de una muestra de 250 proyectos tomadas del repositorio de Scratch. Se propuso comparar esos prototipos con los proyectos representativos de los 3 clústeres conseguidos en nuestro dataset.  

\begin{table}[H]
    \begin{subtable}[h]{0.49\textwidth}
        \centering
        \begin{tabular}{lrrr}
            {} & \multicolumn{3}{c}{\cellcolor[HTML]{FFCCC9}\textbf{Clúster}} \\ 
            \hline
            {} & \textbf{1} & \textbf{2} & \textbf{3} \\ 
            \hline
            \textbf{Pensamiento lógico} & 0 & 2 & 2 \\
            \textbf{Abstracción} & 0 & 0 & 3 \\
            \textbf{Interactividad con el usuario} & 1 & 2 & 2 \\
            \textbf{Representación de los datos} & 0 & 2 & 2 \\
            \textbf{Paralelismo} & 1 & 2 & 3 \\
            \textbf{Sincronización} & 1 & 1 & 2 \\
            \textbf{Control de flujo} & 1 & 1 & 2 \\ 
            \hline
            \textbf{Total} & 4 & 10 & 16 \\ 
            \hline
        \end{tabular}
        \caption{Dataset de 269842 proyectos}
        \label{table:prototype_269842}
    \end{subtable}
    ~
    \begin{subtable}[h]{0.49\textwidth}
        \centering
        \begin{tabular}{lrrr}
        {\color[HTML]{000000} {}} & \multicolumn{3}{c}{\cellcolor[HTML]{CBCEFB}\textbf{Clúster}} \\ 
            \hline
            {} & \textbf{1} & \textbf{2} & \textbf{3} \\ \hline
            \textbf{Pensamiento lógico} & 0 & 0 & 3 \\
            \textbf{Abstracción} & 1 & 1 & 3 \\
            \textbf{Interactividad con el usuario} & 1 & 1 & 2 \\
            \textbf{Representación de los datos} & 1 & 1 & 2 \\
            \textbf{Paralelismo} & 1 & 3 & 3 \\
            \textbf{Sincronización} & 1 & 2 & 3 \\
            \textbf{Control de flujo} & 2 & 2 & 2 \\ 
            \hline
            \textbf{Total} & 7 & 10 & 18 \\ 
            \hline
        \end{tabular}
        \caption{Muestra de 250 proyectos}
        \label{table:prototype_250}
    \end{subtable}
    \caption{Similitud entre proyectos representativos de los 3 clústeres tras aplicar K-Means}
\end{table}

%Si haces tres clústeres (con K-Means, por ejemplo), ¿los proyectos representativos de cada clúster son similares a los que obtuvimos en el paper (ver Tabla 4 del paper)?
Para el clúster 1 de la tabla~\ref{table:prototype_269842} tenemos una puntuación total de 4 en el nivel básico, con un punto en las siguientes habilidades: interactividad con el usuario, paralelismo, sincronización y control de flujo. Se corresponde con un proyecto con 2 scripts que comienzan a e ejecutarse al pulsar la bandera verde, incluyen un bloque de espera y su flujo de ejecución es secuencial. En la tabla~\ref{table:prototype_250} se alcanzan 7 puntos totales para el clúster 1. Difiere en que se consigue 1 punto en abstracción y en representación de los datos, y 2 puntos en control de flujo por emplear bucles infinitos. Que se consiga menos puntuación tiene sentido, ya que en el estudio~\cite{moreno17:_paths} se estableció como requisito una complejidad mínima de 3 puntos totales para los proyectos de la muestra. No se tienen en cuenta los proyectos no completados que aquí sí se consideran.

Para el clúster 2, en el patrón establecido por el prototipo de nivel intermedio de nuestro dataset~\ref{table:prototype_269842}, se refuerzan tanto interactividad con el usuario como paralelismo, pues hay varios programas que se ejecutan simultáneamente al pulsar sobre un objeto o sobre una tecla (2 puntos). Se emplean variables para almacenar los datos de entrada que son procesados por los programas y se decide entre distintas salidas según se cumpla o no una condición, desarrollándose tanto la representación de los datos como el pensamiento lógico, que serían los núcleos de esta fase de aprendizaje.
En la tabla~\ref{table:prototype_250}, el proyecto que describe el clúster 2 logra la misma puntuación total (10 puntos), pero se progresa en habilidades distintas, concretamente en paralelismo y sincronización por el intercambio de mensajes entre varios personajes, con 3 y 2 puntos respectivamente. El resto de destrezas conservan las mismas puntuaciones que en el clúster 1.

El proyecto representativo del clúster 3 marca un nivel avanzado de 16 puntos, como se refleja en la tabla~\ref{table:prototype_269842}. Se consigue un notable progreso al hacer que varios personajes puedan intercambiar mensajes para ejecutar sentencias de manera concurrente. Se emplean clones que muestran una capacidad avanzada en abstracción y bucles por los que se obtiene 2 puntos en control de flujo. En la tabla~\ref{table:prototype_250}, el prototipo de la última fase en el itinerario establecido muestra una complejidad de 18 puntos en vez de 16. El aumento de 2 puntos se debe a que se cuenta con mecanismos avanzados de sincronización y con operadores lógicos para evaluar condiciones, propios de un alto desarrollo del pensamiento lógico. Es el clúster que más se parece al obtenido en nuestro análisis. La variación incremental se debe a que aquí se tienen en cuenta todos los proyectos, incluidos áquellos que están en progreso, para que el programador los mejore y en el artículo se seleccionó una muestra de proyectos con cierto nivel de elaboración.


\subsection{Análisis de clustering entre niveles o puntuaciones totales. Ruta de aprendizaje demostrada en los proyectos de Scratch}
\label{subsec:ruta_Scratch}

En base al itinerario de aprendizaje en 3 etapas basado en prototipos propuesto en el apartado~\ref{subsec:kmeans_Scratch}, se  busca conocer en detalle el proceso de aprendizaje demostrado por los proyectos de Scratch analizados que conforman nuestro dataset. 
En el estudio de las distribuciones por puntuaciones asignadas a las habilidades del PC del apartado~\ref{subsec:corr_21_Scratch}, se vislumbraba, en algunos casos, una única dimensión cuyo desarrollo provocaba el salto al siguiente nivel de complejidad o puntuación total. Sin embargo en la mayoría de ellos no era tan evidente. Tampoco quedaba claro qué combinación de dimensiones conformaba la puntuación total. 
Aunque sí se podía percibir qué capacidades comienzan a adquirirse antes, cuáles después y estimar cuál es su evolución conjunta e individualizada según se incrementa la dificultad.

Para responder de una manera más precisa a estas cuestiones, se agrupan de nuevo los proyectos según su puntuación total, aplicando el algoritmo clustering K-Means a cada uno de los 22 grupos. Se haya el proyecto más representativo de cada grupo. 
Con ello se consigue determinar el camino de aprendizaje seguido y la habilidad cuya mejora provoca el cambio de una puntuación total a la siguiente, que se refleja en la figura~\ref{fig:path_Scratch}.


\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{img/path_CT_Scratch1.png}
  	\caption{Ruta de aprendizaje de las dimensiones del PC en Scratch}\label{fig:path_Scratch}
\end{figure}

\begin{itemize}
 \item El cambio de nivel entre 0 y 1: La primera competencia desarrollada es interactividad con el usuario, ya que el programa cuenta con el bloque que inicia su ejecución al pulsar la bandera verde.
 \item El cambio de nivel entre 1 y 2: Como se veía en la distribución~\ref{fig:total2}, los proyectos con 2 puntos cuentan con 2 o más scripts que se ejecutan a la vez al activar la bandera verde.
 \item El cambio de nivel entre 2 y 3: Paralelismo incrementa su valor de 1 a 2 puntos, al incluir las opciones de pulsar una tecla o sobre un objeto como bloques que desencadenan la ejecución simultánea de varios programas o tareas cuando dicho evento se produce.
 \item El cambio de nivel entre 3 y 4: Se implementa cada programa como una sucesión finita y ordenada de pasos concretos y bien definidos, por lo que se empieza a comprender el concepto de algoritmo, y qué fallos acarrea una incorrecta secuenciación. Por ello se asigna un punto a control de flujo. Se define con mayor exactitud lo intuido al comparar las distribuciones~\ref{fig:total3} y~\ref{fig:total4}. 
 \item El cambio de nivel entre 4 y 5: Sincronización empieza a puntuar al usar bloques de espera que establecen el orden temporal en que se ejecutan las tareas de distintos hilos. %flujos de código.
 \item El cambio de nivel entre 5 y 6: Se modifican los atributos asignados a cada personaje u objeto del proyecto, por lo que se logra un punto en representación de los datos.
 \item El cambio de nivel entre 6 y 7: Se comienza a desarrollar el pensamiento lógico, de modo que se implementa una acción determinada sujeta a que se cumpla cierta condición o premisa.
 \item El cambio de nivel o puntuación total entre 7 y 8: Interactividad del usuario pasa a valer 2 puntos, como se indicaba en la distribución~\ref{fig:total8}. Los personajes u objetos son controlados por el teclado o por el ratón. Se gestiona como responde el programa cuando ocurren estos eventos provocados por el usuario.
 \item El cambio de nivel entre 8 y 9: Abstracción es la destreza más compleja y por ello la última en obtener un punto. Se extrae lo relevante de un problema y se descompone en tareas concretas, ejecutadas por varios personajes, más fáciles de implementar, depurar y mantener.
 \item El cambio de nivel entre 9 y 10: En este paso son varias las capacidades que experimentan cambios. Abstracción vuelve a los 0 puntos, mientras que representación de los datos consigue los 2 puntos al utilizar variables como contenedores de un dato que se modifica o que es evaluado para la ejecución de una secuencia de instrucciones. Se emplean por tanto, estructuras selectivas if-else que evalúan una condición determinando por dónde continúa el flujo del programa, y que acción debe llevarse a cabo. Por ello, en lógica se obtienen 2 puntos.
 \item El cambio de nivel entre 10 y 11: Abstracción recupera el punto al implementarse la solución del problema en varios programas más simples y para varios personajes.
 \item El cambio de nivel entre 11 y 12: Se utilizan bucles que repiten la ejecución de sentencias un nº determinado o indefinido de veces, reforzando la capacidad de control de flujo que consigue un nivel intermedio de desarrollo valorado con 2 puntos.
 \item El cambio de nivel entre 12 y 13: En abstracción se consiguen 2 puntos. El programador de Scratch define procedimientos o funciones propias que pueden ser reutilizadas en el objeto donde se crearon, llamándolas con los parámetros de entrada que se requieran. %se profundiza en el diseño algorítmico  Programación modular. Divide y vencerás. programación top-down. Al descomponer la solución del problema en programas ...  
 \item El cambio de nivel o puntuación total entre 13 y 14: Sincronización toma un valor de 2 puntos. Se emplean el intercambio de mensajes y mecanismos de parada para establecer el orden en que se ejecutan las acciones, de manera que los personajes y programas del proyecto interactúen entre sí.
 \item El cambio de nivel entre 14 y 15: Se declaran listas o estructuras de datos ordenadas, mutables y dinámicas, que almacenan un conjunto de strings o números, requeridos por el programa y cuyos valores son modificados por instrucciones propias de listas durante la ejecución del mismo. Por ello, representación de los datos es la primera capacidad completamente desarrollada y marca el paso al nivel avanzado.
 \item El cambio de nivel entre 15 y 16: Abstracción incrementa su valor a 3 puntos por el uso de clones, que son instancias de un objeto con los mismos atributos y métodos, creados dinámicamente cuando se necesitan varias copias del personaje original con el mismo comportamiento. Facilita el mantenimiento y la modificación del código. % diferente estado pues se puede modificar posición... 
 \item El cambio de nivel entre 16 y 17: Se utilizan operadores lógicos para evaluar condiciones y decidir si se ejecuta el código implementado asociado. Al combinar el diseño de algoritmos selectivos con la lógica booleana se consigue la máxima puntuación en pensamiento lógico. Paralelismo consigue también 3 puntos, pues se ejecutan simultáneamente varios scripts cuando reciben un mensaje, cambia el escenario o cuando se producen otros eventos multimedia. En representación de los datos se baja a los 2 puntos, pues se emplean variables para almacenar los datos con los que trabaja el programa y no listas.
 \item El cambio de nivel entre 17 y 18: De nuevo se declaran y modifican listas en los programas del proyecto de Scratch. 
 Por lo tanto, representación de los datos vuelve a valer 3 puntos.
 \item El cambio de nivel entre 18 y 19: Se establecen mecanismos de sincronización condicionales o basados en eventos, como el cambio de escenario. La ejecución de un programa continúa cuando se obtiene cierto resultado en otro proceso que envía los datos y espera que sean procesados para continuar con su flujo. Por ello, sincronización vale 3 puntos. %% Esperar hasta, cuando el fondo cambie a, enviar y esperar 

 \item El cambio de nivel entre 19 y 20: Control de flujo alcanza los 3 puntos, puesto que se refuerza la comprensión de los algoritmos iterativos al utilizar bucles sujetos a condiciones. Concuerda con lo obtenido en la distribución ~\ref{fig:total20}. % repetir hasta
 \item El cambio de nivel o puntuación total entre 20 y 21: Se implementan acciones a realizar por los objetos empleando bloques sensores que detectan cambios en la intensidad del sonido o movimiento cuando el usuario emplea el micrófono o la webcam para actuar sobre el proyecto. Interactividad del usuario es la última habilidad que se completa, como ya se indicó en el apartado~\ref{subsec:corr_21_Scratch}. 
\end{itemize}

\section{Análisis de datos de proyectos de Snap!} 
\label{sec:result_snap}
% Por lo demás, intenta siempre contar una historia: además de mostrar los resultados, que eso se os da bien, piensa en la motivación (por qué), en el método (cómo) y en las consecuencias (¿para qué?). 

\subsection{Extracción y limpieza de datos}
\label{subsec:clean_data_Snap}

% En diseño poner descripción detallada recolección de datos \texttt{project.xml} 
A partir de un directorio de proyectos de Snap! almacenados como ficheros XML, se obtiene la evaluación de los proyectos tras modificar sus métricas y adaptar el código de Dr. Snap!, para que puedan ser analizados a través de su path, gracias a un script de python. Estas evaluaciones son volcadas al fichero \emph{results\_snap\_metrics.csv}. 

En el Jupyter Notebook \emph{ Dr\_Snap\_complete\_analysis.ipynb}\footnote{\url{https://github.com/rcruiz/DrSnap-Analysis}} se cargan los datos del fichero CSV en un dataframe que consta de 113906 filas y 12 columnas. Por lo tanto, nuestro dataset en bruto está conformado por 113906 muestras u observaciones que son los proyectos de Snap! caracterizados por 12 atributos o variables. Cada proyecto queda identificado por su nombre y su ruta absoluta. 
Las métricas establecidas para evaluar el desarrollo del pensamiento computacional determinan 7 dimensiones valoradas con puntuaciones enteras entre 0 y 3 puntos, que son: condicionales, sincronización, control de flujo, abstracción, paralelismo, interactividad con el usuario y representación de los datos. Al agregarlas se obtiene otra variable discreta, la puntuación total. A partir de ella se obtiene el valor medio definido en un rango continuo [0, 3] y se asigna un nivel de desarrollo: básico, intermedio y avanzado. Los 5 primeros proyectos y sus atributos correspondientes se reflejan en la figura~\ref{fig:df_Snap}.

% Las 7 habilidades del pensamiento computacional evaluadas con puntuaciones discretas en el rango [0, 3] son: condicionales, sincronización, control de flujo, abstracción, paralelismo, interactividad con el usuario y datos. De su suma se obtiene el total y se asigna el valor medio y el nivel de dominio del pensamiento computacional demostrado en el proyecto, que puede ser básico, intemedio y avanzado. En la figura~\ref{fig:df_Snap} se representa la estructura de datos de los 5 primeros proyectos y los atributos correspondientes.  

\begin{figure}[H]
    \centering
    \includegraphics[width=1.0\textwidth]{img/df_origen_Snap.png}
    \caption{Dataframe de los proyectos de Snap! obtenido al cargar \emph{results\_snap\_metrics.csv}}
    \label{fig:df_Snap}
\end{figure}

Se transforman los tipos de datos de la característica nivel a categórico ordinal y de las puntuaciones a enteros sin signo, para facilitar su posterior procesamiento y para que la extensa base de datos ocupe menos en memoria. Se completa la limpieza del conjunto de proyectos eliminando áquellos sin nombre asignado y comprobando si existen duplicidades.

Se verifica que existen 56242 con nombre único aunque todos tienen distinto path. Se debe a que varios programadores de Snap! se basaron en la misma animación o videojuego para implementar e incrementar la complejidad de sus proyectos, siguiendo algún curso, como el propuesto por Berkeley\footnote{\url{https://bjc.edc.org/bjc-r/topic/topic.html?topic=nyc_bjc/1-intro-loops.topic&course=bjc4nyc.html&novideo&noassignment}}. Posteriormente se subieron al repositorio de Snap! con el mismo nombre asignado. De hecho existe un proyecto que es la moda del conjunto total de proyectos, al ser el más frecuente, pues se repite 2085 veces, ``U1L1-ClickAlonzo'', perteneciente a dicho curso.

\subsection{Análisis de los proyectos de Snap! por nivel o categoría asignada y puntuación total. Distribución de frecuencias}
\label{subsec:frec_nivel_Snap}

¿Cómo es la distribución de los proyectos de Snap! por nivel?

Se continúa explorando la información contenida en los datos clasificando los proyectos de Snap! en función de la categoría de desarrollo alcanzado. Como se visualiza en la figura~\ref{fig:df_Snap}, según aumenta la complejidad las frecuencias absolutas y relativas disminuyen. La mayoría de los proyectos no superan el nivel básico, en concreto un 53,69\% de la población total analizada. El nivel intermedio reúne un 39,17\% del conjunto total, que suponen 44609 proyectos. Tan solo 8137 proyectos, un 7,14\%, logran superar el umbral de los 14 puntos. Se debería fomentar el aprendizaje de conceptos y prácticas del pensamiento computacional para que los programadores de Snap! incrementen la dificultad de sus proyectos y se valoren los aspectos más avanzados de cada dimensión. Con ello obtendrían puntuaciones globales mayores y subirían de nivel.

\begin{figure}[H]
    \centering
    \includegraphics[width=.95\textwidth]{img/freq_level_Snap.png}
    \caption{Distribución de proyectos de Snap por nivel asignado}\label{fig:level_Snap}
\end{figure}

¿Cómo se distribuyen los proyectos de Snap! entre las puntuaciones asignadas a cada nivel?

Se busca conocer más en detalle cómo se reparten las proyectos según las puntuaciones que determinan la pertenencia a cada una de las tres etapas de desarrollo.

En la distribución~\ref{fig:basic_Snap} del nivel básico, la puntuación nula es la que menos veces aparece. Se incrementa la frecuencia de los proyectos hasta alcanzar un máximo en los 5 puntos, con 14302 proyectos de Snap! valorados con dicha puntuación. Se mantiene una frecuencia absoluta elevada para las calificaciones de 6 y 7, con 12134 y 11529 proyectos respectivamente.

\begin{figure}[H]
    \centering
    \begin{subfigure}[h]{.7\textwidth} 
        \includegraphics[width=\textwidth]{img/basic_Snap}
        \caption{Nivel básico}
        \label{fig:basic_Snap}
    \end{subfigure}       
    \begin{subfigure}[h]{.7\textwidth} 
        \includegraphics[width=\textwidth]{img/intermediate_Snap}
        \caption{Nivel intermedio}
        \label{fig:intermediate}
    \end{subfigure}
    \begin{subfigure}[h]{.7\textwidth} 
        \includegraphics[width=\textwidth]{img/advanced_Snap}
        \caption{Nivel avanzado}
        \label{fig:advanced}
    \end{subfigure}
    \caption{Distribución de proyectos de Snap por puntuaciones asignadas a cada nivel}
\end{figure}

En el nivel intermedio mostrado en la figura~\ref{fig:intermediate}, se sigue una tendencia descendente en las cantidades de proyectos atribuidas a cada puntuación, desde el máximo local situado en los 9 puntos con 10389 proyectos, hasta los 14 puntos con 3120 proyectos. Esta tendencia continúa en el nivel avanzado, con 2603 proyectos valorados con 15 puntos, magnitud que disminuye hasta los ínfimos 129 proyectos que logran 20 puntos y 8 proyectos que consiguen la excelencia en el desarrollo de todas las habilidades consideradas, como queda reflejado en la figura~\ref{fig:advanced}.
% media - mediana = 50\% de los datos dispersos hacia
En la tabla~\ref{table:mean_Snap} se comprueba que al ser la media del nivel básico menor que la mediana, la distribución tiene una asimetría negativa o hacia la izquierda. La mediana coincide con la moda para este nivel. En los niveles intermedio y avanzado la media supera a la mediana, y la asimetría es positiva o hacia la derecha, como también se percibe en los diagramas de barras~\ref{fig:intermediate} y~\ref{fig:advanced}.
Las dispersiones con respecto a la media son más bajas que las obtenidas en Scratch (ver tabla~\ref{table:mean_Scratch}), por lo que la media se ve menos influenciada por puntuaciones extremas. 

\begin{table}[H]
 \begin{center}
  \begin{tabular}{|c|c|c|c|c|}
    \hline
     \textbf{Nivel} & \textbf{Media} & \textbf{Mediana} & \textbf{Varianza} & \textbf{Desviación típica} \\ \hline
    \textbf{Básico} & 4.717211 & 5 & 3.433791 & 1.853049 \\ \hline
    \textbf{Intermedio} & 10.166984 & 10 & 3.520650 & 1.876339 \\ \hline
    \textbf{Avanzado} & 16.375814 & 16 & 1.696996 & 1.302688 \\ \hline
  \end{tabular}
  \caption{Medidas de tendencia central y dispersión para cada nivel de Snap!}
  \label{table:mean_Snap}
 \end{center}
\end{table}

¿Cómo se distribuyen los proyectos de Snap! según la puntuación total?

\begin{figure}[H]
    \centering
    \includegraphics[width=.9\textwidth]{img/frequency_total_score.png}
    \caption{Distribución de proyectos de Snap! por puntuación total.}\label{fig:total}
\end{figure}

Como se aprecia en la figura~\ref{fig:total} existe una mayor concentración de los proyectos entre las puntuaciones totales de 4 y 10 puntos. La moda se localiza en los 5 puntos. La frecuencia decae abruptamente para las puntuaciones más bajas y disminuye de manera más suave para las puntuaciones más altas. Existe una asimetría positiva o hacia la derecha. %

Por lo tanto, más de la mitad de los proyectos de Snap! se aglutinan en una etapa inicial o básica de aprendizaje del pensamiento computacional, siendo la calificación total más frecuente 5 puntos. Los programadores de Snap!, cuyos proyectos conforman nuestro dataset, deberían presentar puntuaciones totales superiores si realmente contaran con conocimientos previos. Sería oportuno que recibieran realimentación de cómo mejorar sus proyectos y se sintieran incentivados a incrementar la complejidad de los problemas que resuelven con ellos, para así poder mejorar en las distintas dimensiones y obtener mejores resultados globales. %%% CT formative–iterative tools:  motivados mejorar el desempeño

\subsection{Frecuencia de los proyectos de Snap! por áreas del pensamiento computacional}
\label{subsec:frec_pc_Snap}

¿Cuál es la distribución de la puntuación en cada dimensión?

% Se analiza si dichas valoraciones poseen una complejidad creciente con métricas discriminantes, que provoquen distribuciones decrecientes.
%  se desglosa en función de las siete capacidades que caracterizan el pensamiento computacional y se calcula la cantidad de proyectos que consiguen las puntuaciones de 0, 1, 2 y 3 en cada una de estas dimensiones.
Se desglosa en función de cada una de las siete habilidades del PC y se halla la distribución de proyectos para cada puntuación entera entre 0 y 3. Los resultados concretos así como su representación gráfica pueden verse en las figuras~\ref{fig:df_PC_Snap} y~\ref{fig:barras_PC_Snap}. 

\begin{figure}[H]
    \centering      
    \begin{subfigure}[h]{1\textwidth} 
        \includegraphics[width=\textwidth]{img/df_PC_Snap.png}
        \caption{Dataframe con la cantidad de proyectos por puntuación y dimensión del PC}
        \label{fig:df_PC_Snap}
    \end{subfigure}
    \begin{subfigure}[h]{1\textwidth} 
        \includegraphics[width=\textwidth]{img/distribution_PC_Snap.png}
        \caption{Diagrama de barras con la cantidad de proyectos por puntuación y dimensión del PC}
        \label{fig:barras_PC_Snap}
    \end{subfigure} 
\caption{Distribución de proyectos de Snap! por puntuación para cada dimensión del PC}
\end{figure}
Se corrobora que las métricas establecidas representen una complejidad creciente que se traduzca en una distribución decreciente, de manera que la cantidad de proyectos que consiguen las puntuaciones más altas en cada capacidad desarrollada sea cada vez menor. % métricas discriminantes y dotadas de expresividad.  

\begin{itemize}
    
    \item \textbf{Condicionales}: Relacionado con el pensamiento lógico que permite discernir qué salidas se generan en función de diferentes situaciones o entradas. Es la habilidad menos desarrollada puesto que 73670 proyectos no utilizan ni if, ni if-else, ni operadores lógicos como estructuras selectivas que definen por dónde continúa el flujo del programa. Únicamente 21182 usan un tipo de condicional, y una cantidad aún menor de proyectos emplean 2 o los 3 condicionales especificados, 12623 y 6419, respectivamente.
    
    \item \textbf{Sincronización}: Es la segunda capacidad menos desarrollada pues en más de la mitad de los proyectos no existen bloques de espera, de parada, de intercambio de mensajes o sujetos a eventos y condiciones que organicen cómo interactúan y se comunican los distintos flujos de código y los personajes del proyecto. % procesos, hilos
    
    \item \textbf{Control de flujo}: La mayoría de los proyectos se concentran en torno a 1 y 2 puntos por resolver problemas de manera sistémica, ordenada y precisa mediante algoritmos con un flujo lineal o iterativo con bucles definidos o indefinidos.
    Más de 16000 proyectos consiguen 3 puntos por utilizar bucles sujetos a condiciones.
    
    \item \textbf{Abstracción}: Se aplica un diseño algorítmico basado en la programación modular y en la técnica ``divide y vencerás'' para resolver problemas complejos dividiéndolo en partes más sencillas. Se cuenta con 59468 proyectos con 1 punto obtenido por contener más de un script y más de un \emph{sprite} o personaje, o una función definida por el programador encargada de una tarea concreta, o clones. Desciende a 18501 los proyectos que consiguen 2 puntos por usar dos de estas técnicas. Únicamente 1297 proyectos emplean todos las elementos de abstracción descritos.
    
    \item \textbf{Paralelismo}: En 30270 proyectos se cuenta con un personaje u objeto que realiza simultáneamente varias tareas, mientras que en 25960 hay 2 o más objetos que ejecutan los mismos programas a la vez, cuando se pulsa una tecla o la bandera verde.
    Disminuye a 17479 los proyectos con procesos o hilos en paralelo que activan su ejecución cuando reciben mensajes, condiciones o son clones.
    
    % Videojuegos en cuenta los eventos que introduce el usuario en el programa
    \item \textbf{Interactividad con el usuario}: La mitad de los proyectos son valorados con 1 punto por implementar acciones que respondan a que el usuario pulse una tecla, la bandera verde o actúe sobre un objeto. Se consiguen 2 puntos en 33119 proyectos cuando el usuario debe contestar a una pregunta, o mover el ratón o un personaje. Solo en 4360 proyectos los objetos son controlados por las modificaciones de audio o vídeo que introduce el usuario durante su ejecución.
    
    \item \textbf{Representación de los datos}: La capacidad que indica cómo se manejan y abstraen los datos requeridos por los programas consigue puntuaciones en sentido descendente. Hay más de 50000 proyectos donde se especifican los atributos de los personajes, 23910 en los que se declaran y modifican variables y 19088 que cuentan con operaciones sobre listas. % listas son de primera clase se pueden construir listas de listas, estructuras de datos bidimensionales, listas dinámicas y listas enlazadas.
    
\end{itemize}    

\subsection{Análisis estadístico general de las dimensiones del pensamiento \\computacional con Snap!}
\label{subsec:estad_pc_Snap}

Se sigue con el análisis exploratorio de los datos desde un enfoque descriptivo univariante calculando las medidas de tendencia central, variabilidad y posición que resumen y caracterizan cada variable analizada del pensamiento computacional. Se reflejan en la figura~\ref{fig:describe_Snap}.
%Control de flujo y representación de los datos consiguen las mayores medias y medianas, %indicando que el centro de gravedad de las observaciones o proyectos proyectos de Snap! se sitúa en una puntuación más alta y el 50\% de los proyectos de Snap! ordenados de menor a mayor puntuación tienen las puntuaciones más altas

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{img/describe_Snap.png}
    \caption{Media, desviación estándar y cuartiles de cada CT}
    \label{fig:describe_Snap}
\end{figure}

Control de flujo y representación de los datos consiguen las mayores medias y medianas, por lo que se deduce que son las destrezas que se adquieren con más facilidad, mientras que las menores medias y medianas son para condicionales y sincronización. El hecho de que no se apliquen en la mitad de los proyectos puede deberse a que no se requiera o resulten complicadas. Las habilidades con menor dispersión con respecto a la media son abstracción, interactividad con el usuario y control de flujo, como se concluye a partir de la desviación típica. Para el resto de capacidades su valor es elevado, en torno a 1,
%La muestra de proyectos de Snap! analizados es suficientemente grande para que se vea menos afectada por la presencia de \emph{outliers} pero  
% la desviación típica es muy sensible a la presencia de valores atípicos, por lo que se requiere analizar los 5 números que resumen y caracterizan la distribución para cada dimensión. %ojo 
por lo que la mediana será más representativa que la media. En la figura~\ref{fig:describe_Snap} se indica además el valor de los cuartiles, que serán estudiados con mayor detalle en el diagrama de cajas~\ref{fig:cajas_Snap}. %La mediana más robusta frente a valores atípicos si la muestra es reducida. La variación media con respecto a la media es más sensible que MAD a outliers
Nos muestra la dispersión de los proyectos ordenados de menor a mayor puntuación y podemos identificar si existen valores atípicos. Al representarlos en el mismo gráfico se puede comenzar a intuir alguna relación entre las dimensiones, aunque se siga con el análisis univariante.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{img/diag_cajas_Snap.png}
    \caption{Diagrama de cajas de cada dimensión del CT}
    \label{fig:cajas_Snap}
\end{figure}

\begin{itemize}
    \item \textbf{Condicionales, sincronización y abstracción}: Como ya se ha indicado la mitad de los proyectos no consiguen puntuar en condicionales y sincronización, estando el primer y el segundo cuartil en 0 puntos. Sin embargo, en sincronización el rango intercuartílico es de 2 puntos, implicando mayor dispersión de proyectos de Snap! entre la mediana y el $Q_3$ y que los 3 puntos marquen el límite superior, en vez de ser considerados valores atípicos o \emph{outliers}. Los proyectos con 3 puntos también son \emph{outliers} en abstracción, aunque igualmente válidos en nuestro estudio. En dicha dimensión, el 25\% de los proyectos tienen 0 puntos, la mitad de los proyectos son evaluados con 0 o 1 punto, y todos los proyectos entre la mediana y el tercer cuartil, se concentran en 1 punto. % Como 1.5 * Rango intercuartil + Q3 = 2.5 
    \item \textbf{Paralelismo}: Su rango intercuartil es de 2 puntos con la mediana en 1 punto. Con respecto a las otras habilidades, las puntuaciones de los proyectos presentan mayor dispersión a ambos lados de este valor central, de modo que la mitad de los proyectos tienen 0 y 1 puntos, al llegar al $Q_3$ algunos obtienen 2 puntos, y el límite superior está en 3 puntos.
    \item \textbf{Interactividad con el usuario, representación de los datos y control de flujo}: Las tres capacidades concentran la mitad de los proyectos entre 1 y 2 puntos, como se aprecia en el rango intercuartílico comprendido entre $Q_1$ y $Q_3$. Los proyectos están más dispersos para las puntuaciones inferiores en control de flujo, como se deduce de la posición del $Q_1$ y del $Q_2$, que para las puntuaciones superiores. Los valores se concentran en torno a 2 puntos, donde mediana y $Q_3$ coinciden. En cambio, en las otras dos capacidades, la asimetría es hacia la derecha, pues la primera mitad de los proyectos logran 1 punto, mientras que en la mitad superior obtienen valores entre 1, 2 y 3 puntos.
\end{itemize}

Para profundizar en las relaciones que puedan establecerse entre las habilidades y entre éstas con el total, se recurre al análisis descriptivo bivariante y en concreto a los coeficientes de correlación lineal de Pearson. Primero, se comprueba si existe una asociación lineal perfecta entre cada una de las capacidades consideradas del pensamiento computacional con la puntuación total obtenida. Se recogen en la tabla~\ref{table:corr_total_Snap} los valores de los coeficientes. 
El menor grado de dependencia lineal con el total se produce en representación de los datos y abstracción. Al desarrollarse estas dimensiones, la puntuación total aumenta en menor medida que si se fomentan el resto de habilidades. Serían las que más información y expresividad aportan. Tanto en paralelismo como en sincronización existe una elevada dependencia lineal con el total. %Desarrollando estas capacidades se incrementa la puntuación total con mayor probabilidad que con el resto de habilidades. 

\begin{table}[htbp]
 \begin{center}
 \resizebox{15cm}{!} {
    \begin{tabular}{|c|c|c|c|c|c|c|c|}
    \hline
    \textbf{Correlación} & \textbf{Condicionales} & \textbf{Sincronización} & \textbf{Control de flujo} & \textbf{Abstracción} & \textbf{Paralelismo} & \textbf{\begin{tabular}[c]{@{}c@{}}Interactividad\\ con el usuario\end{tabular}} & \textbf{\begin{tabular}[c]{@{}c@{}}Representación\\ de los datos\end{tabular}} \\
    \hline
    \textbf{Total} & 0.641439 & 0.734082 & 0.595380 & 0.514194 & 0.740135 & 0.667972 & 0.491424 \\
    \hline
    \end{tabular} }
    \caption{Correlación de la puntuación total con cada dimensión del PC}
    \label{table:corr_total_Snap}
 \end{center}
\end{table}

Es precisamente entre sincronización y paralelismo donde existe mayor dependencia lineal en sentido positivo, como se observa en la matriz de correlación~\ref{fig:corr_Snap}.
Cuando en un proyecto de Dr. Snap! se ejecutan varios flujos de código a la vez, se necesitan mecanismos que organicen esa ejecución simultánea. Condicionales e interactividad con el usuario presentan una correlación positiva moderada. Cuando el usuario interactúa con el proyecto moviendo los objetos, con el ratón o pulsando una tecla y contestando a preguntas,
se incrementa el uso de condicionales, seleccionando el conjunto de sentencias a ejecutar según la acción realizada. Abstracción y control de flujo son independientes linealmente. La descomposición del problema en scripts y funciones propias encargadas de tareas concretas no guarda relación con las nociones algorítmicas demostradas en cada script o función.
Interactividad con el usuario y abstracción y representación de los datos con el resto de dimensiones también están incorreladas, con valores de $\rho\approx0$.

\begin{figure}[H]
    \centering
    \includegraphics[width=.7\textwidth]{img/corr_Snap.png}
    \caption{Matriz de correlación de Pearson de las dimensiones del PC.}\label{fig:corr_Snap}
\end{figure}

\subsection{Frecuencias y correlaciones de las dimensiones del PC en función de la puntuación total para proyectos de Snap!}
\label{subsec:corr_21_Snap}

Se busca ver la evolución de las correlaciones existentes entre cada par de habilidades según se incrementa la complejidad global de los proyectos, así como la distribución de puntuaciones en cada habilidad para cada puntuación total. Podemos hacernos una idea de qué habilidades son más difíciles de adquirir y de cómo los programadores de Snap! progresan en ellas.

Como en el apartado~\ref{subsec:corr_21_Scratch}, se descartan los valores mínimo y máximo de la puntuación total, ya que todas las habilidades tienen la misma puntuación en cada proyecto de Snap! y no existen variaciones con respecto al valor medio, ni entre cada par de variables de manera conjunta, ni en cada una de ellas por separado. Así la covarianza y la desviación típica son nulas cuando el total es 0 o 21 y el cálculo de su coeficiente de correlación no tiene sentido (ver fórmula~\eqref{eq:correlacion}). % prob condicionada variable pierde su variabilidad y tiene un valor conocido, determinado. Probabilidad condicionada a puntuación total obtenida. Muy similar a lo del apartado... 

Los proyectos más simples evaluados con 1 punto consiguen esta valoración principalmente por el desarrollo de la abstracción, como se demuestra en el diagrama de barras~\ref{fig:total1_Snap}. Llama la atención que la descomposición del problema en partes sencillas sea la primera habilidad en manifestarse. Estos proyectos contienen funciones definidas por el programador, varios scripts que resuelven subproblemas bien definidos y varios personajes u objetos cada uno con sus propios atributos y programas, o clones que son instancias de los objetos. En la matriz de correlación~\ref{fig:corr1_Snap} las dependencias lineales son perfectas positivas entre cada par de dimensiones con valores nulos, salvo en abstracción con el resto de dimensiones, donde es perfecta negativa. % clones creados dinámicamente o no en Snap!

\begin{figure}[H]
    \centering
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/distribucion_1_Snap}
        \caption{Diagrama de barras. Total=1}
        \label{fig:total1_Snap}
    \end{subfigure}       
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/corr_1_Snap}
        \caption{Matriz de correlación. Total=1}
        \label{fig:corr1_Snap}
    \end{subfigure}
     \caption{Distribución de puntuaciones asignadas y correlación entre dimensiones del PC cuando la puntuación total vale 1}
\end{figure}

\begin{figure}[H]
    \centering
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/distribucion_2_Snap}
        \caption{Diagrama de barras. Total=2}
        \label{fig:total2_Snap}
    \end{subfigure}       
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/corr_2_Snap}
        \caption{Matriz de correlación. Total=2}
        \label{fig:corr2_Snap}
    \end{subfigure}
     \caption{Distribución de puntuaciones asignadas y correlación entre dimensiones del PC cuando la puntuación total vale 2}
\end{figure}

Como se distingue en la distribución~\ref{fig:total2_Snap}, la puntuación total de 2 se obtiene de las distintas combinaciones del punto conseguido en control de flujo, interactividad con el usuario o abstracción. Entre estas dos últimas se da una correlación positiva casi perfecta. Control de flujo muestra una correlación positiva alta con el resto de dimensiones, mientras que en interactividad con el usuario y abstracción no existe correlación con las habilidades no desarrolladas. Estas dimensiones que no puntúan presentan entre sí correlaciones positivas perfectas, como se ve en la matriz~\ref{fig:corr2_Snap}.


\begin{figure}[H]
    \centering
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/distribucion_3_Snap}
        \caption{Diagrama de barras. Total=3}
        \label{fig:total3_Snap}
    \end{subfigure}       
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/corr_3_Snap}
        \caption{Matriz de correlación. Total=3}
        \label{fig:corr3_Snap}
    \end{subfigure}
     \caption{Distribución de puntuaciones asignadas y correlación entre dimensiones del PC cuando la puntuación total vale 3}
\end{figure}

Aumenta la cantidad de proyectos que consiguen puntuar en representación de los datos y se consigue una ligera mejora en control de flujo, como se distingue en la distribución~\ref{fig:total3_Snap}.

Según la matriz~\ref{fig:corr3_Snap}, en esta puntuación total de 3, surgen altas interdependencias directas entre cada dimensión con interactividad con el usuario, excluyendo control de flujo. Que el usuario presione la bandera verde o una tecla no guarda relación con una secuenciación finita, ordenada y precisa de las instrucciones que penden de esos bloques de inicialización del programa. En cambio sí depende de la resolución del problemas dividiéndolo en funciones o procedimientos encargados de una tarea determinada o empleando instancias de los personajes, propias de la abstracción, o de la modificación de los datos que caracterizan a cada personaje. Representación de los datos también se relaciona fuertemente con control de flujo y abstracción. Sincronización, condicionales y paralelismo siguen sin puntuar y presentan entre sí correlaciones perfectas directas, siendo independientes de control de flujo.

Las diferencias del diagrama de barras~\ref{fig:total4_Snap} correspondiente a la puntuación total de 4 con respecto al anterior, son mayores frecuencias para el punto obtenido en paralelismo e interactividad y para los 2 puntos en control de flujo.

Paralelismo mantiene correlaciones positivas perfectas con sincronización y condicionales, pese a que sea la única que progresa con respecto a las otras dos. Establece con abstracción una dependencia lineal fuerte en sentido positivo. Por ello aumenta la capacidad para ejecutar programas y funciones de manera simultánea cuando el problema se resuelve dividiéndolo en módulos más sencillos de codificar. 
La misma dependencia surge entre interactividad con el usuario y representación de los datos, de forma que cuando el evento que provoca el usuario ocurre, se incrementan las operaciones sobre los atributos de los objetos. 
Abstracción y control de flujo son independientes, las copias de los personajes, y los scripts o bloques encargados de tareas concretas que resuelven el problema en su conjunto, no influye en que se demuestren nociones algorítmicas en su codificación.
Tampoco hay correlación entre condicionales con representación de los datos, ni entre esta última con sincronización. La ausencia tanto de condicionales como de sincronización, no afecta a la capacidad de definir los datos de los personajes que necesitan los programas, que se van modificando durante su ejecución.

% La gestión de las acciones que realiza el usuario sobre el programa tiene una débil dependencia lineal con la correcta aplicación de algoritmos que estructuren el programa como una secuencia finita, precisa y concreta de instrucciones donde puedan aparecer bucles. 

\begin{figure}[H]
    \centering
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/distribucion_4_Snap}
        \caption{Diagrama de barras. Total=4}
        \label{fig:total4_Snap}
    \end{subfigure}       
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/corr_4_Snap}
        \caption{Matriz de correlación. Total=4}
        \label{fig:corr4_Snap}
    \end{subfigure}
     \caption{Distribución de puntuaciones asignadas y correlación entre dimensiones del PC cuando la puntuación total vale 4}
\end{figure}

En la distribución~\ref{fig:total5_Snap}, cuando se filtra para un nivel de complejidad total de 5, los proyectos con 2 puntos prevalecen en control de flujo. En sincronización aumenta la cantidad de proyectos que consiguen 1 punto, si bien la mayoría no puntúan.

En la matriz~\ref{fig:corr5_Snap} se mantiene una correlación perfecta entre sincronización y condicionales. Asimismo, son muy elevadas las dependencias lineales directas entre cada par conformado por abstracción, sincronización y paralelismo. Se descompone el problema en tareas más simples y en personajes para los que se ha establecido un orden temporal en el que ejecutar las distintas acciones de manera concurrente o simultánea, pudiendo interactuar entre sí. El usuario provoca que los objetos ejecuten esos procesos a la vez al pulsar una tecla o cambiando el estado del objeto, modificando las propiedades del objeto, ya sea su posición, disfraz o movimiento, generando altas dependencias entre interactividad con: abstracción, paralelismo y representación de los datos. Sin embargo, sincronización y representación de los datos están incorreladas. Se produce una correlación moderada negativa entre control de flujo y condicionales. 

\begin{figure}[H]
    \centering
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/distribucion_5_Snap}
        \caption{Diagrama de barras. Total=5}
        \label{fig:total5_Snap}
    \end{subfigure}       
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/corr_5_Snap}
        \caption{Matriz de correlación. Total=5}
        \label{fig:corr5_Snap}
    \end{subfigure}
    \caption{Distribución de puntuaciones asignadas y correlación entre dimensiones del PC cuando la puntuación total vale 5}
\end{figure}

\begin{figure}[H]
    \centering
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/distribucion_6_Snap}
        \caption{Diagrama de barras. Total=6}
        \label{fig:total6_Snap}
    \end{subfigure}       
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/corr_6_Snap}
        \caption{Matriz de correlación. Total=6}
        \label{fig:corr6_Snap}
    \end{subfigure}
    \caption{Distribución de puntuaciones asignadas y correlación entre dimensiones del PC cuando la puntuación total vale 6}
\end{figure}

En la distribución~\ref{fig:total6_Snap} la proporción de proyectos con 1 punto en sincronización, paralelismo e interactividad con el usuario se eleva. En menor medida, se consiguen 2 puntos en estas dos últimas, así como en abstracción. Incluso se obtienen 3 puntos al emplear estructuras de datos complejas como entrada de sus programas, siendo la primera capacidad en completarse.

En la matriz~\ref{fig:corr6_Snap} de nuevo se presentan las mismas dependencias casi perfectas entre sincronización y condicionales, interactividad con el usuario y datos, abstracción con paralelismo y abstracción con sincronización. No se producen asociaciones entre interactividad con el usuario con condicionales, representación de los datos con condicionales, sincronización con representación de los datos, ni entre abstracción con control de flujo. Sigue dándose una correlación moderada negativa entre control de flujo con condicionales, de manera que al demostrar nociones algorítmicas por el uso de estructuras iterativas, se reducen los condicionales que permiten obtener distintas salidas según se cumpla o no una situación o un conjunto de ellas.

\begin{figure}[H]
    \centering
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/distribucion_7_Snap}
        \caption{Diagrama de barras. Total=7}
        \label{fig:total7_Snap}
    \end{subfigure}       
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/corr_7_Snap}
        \caption{Matriz de correlación. Total=7}
        \label{fig:corr7_Snap}
    \end{subfigure}
    \caption{Distribución de puntuaciones asignadas y correlación entre dimensiones del PC cuando la puntuación total vale 7}
\end{figure}

En el diagrama de barras~\ref{fig:total7_Snap} disminuye la habilidad demostrada en sincronización, mientras que trasciende la abstracción. En paralelismo se igualan los proyectos con 1 y 2 puntos.

En la matriz de correlación~\ref{fig:corr7_Snap} de la puntuación global de 7, sincronización y condicionales son totalmente interdependientes entre sí puesto que apenas consiguen puntuar. Se conserva una correlación elevada entre interactividad con el usuario y representación de los datos y se obtienen además dependencias lineales elevadas entre cada una de ellas con abstracción. Al dividir la resolución del problema en partes mediante objetos o personajes, bloques personalizados o scripts con una funcionalidad muy concreta más fácil de programar y mantener, o con clones, se modifican y almacenan los datos que requieren en listas, variables, o atributos de los objetos y a su vez se gestionan los eventos causados por el usuario. Paralelismo y control de flujo están fuertemente correladas. Implica que si un personaje realiza varias acciones a la vez o varios personajes ejecutan simultáneamente el mismo código, se incrementa la capacidad de que cada programa siga una estructura secuencial o iterativa. No existe correlación entre paralelismo con condicionales, ni entre paralelismo con sincronización. La correlación negativa más remarcable es la que ocurre entre control de flujo con condicionales, que también se produce en las puntuaciones totales anteriores. %==

\begin{figure}[H]
    \centering
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/distribucion_8_Snap}
        \caption{Diagrama de barras. Total=8}
        \label{fig:total8_Snap}
    \end{subfigure}       
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/corr_8_Snap}
        \caption{Matriz de correlación. Total=8}
        \label{fig:corr8_Snap}
    \end{subfigure}
    \caption{Distribución de puntuaciones asignadas y correlación entre dimensiones del PC cuando la puntuación total vale 8}
\end{figure}

En la puntuación total de 8 el uso de condicionales adquiere mayor relevancia y cerca de unos 1000 proyectos consiguen la máxima puntuación en paralelismo y control de flujo. En interactividad con el usuario y representación de los datos se incrementan los proyectos con 2 puntos, como se aprecia en el gráfico~\ref{fig:total8_Snap}.

En la matriz~\ref{fig:corr8_Snap} se observan correlaciones positivas muy altas entre interactividad con el usuario y representación de los datos, y entre ambas con control de flujo, de forma que se desencadena la ejecución de secuencias y ciclos de sentencias que modifican los atributos de los objetos y los datos contenidos en listas y variables cuando el usuario responde a una pregunta, pulsa una tecla o mueve un objeto con el ratón. Sincronización y condicionales también son interdependientes, pues cuando se codifican sentencias alternativas en función de condiciones, se planifica la interacción de los distintos procesos con bloques de parada, espera e intercambio de mensajes. Interactividad con el usuario y sincronización están incorreladas.

\begin{figure}[H]
    \centering
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/distribucion_9_Snap}
        \caption{Diagrama de barras. Total=9}
        \label{fig:total9_Snap}
    \end{subfigure}       
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/corr_9_Snap}
        \caption{Matriz de correlación. Total=9}
        \label{fig:corr9_Snap}
    \end{subfigure}
    \caption{Distribución de puntuaciones asignadas y correlación entre dimensiones del PC cuando la puntuación total vale 9}
\end{figure}

% Variables: Se le llama variable a un espacio en memoria que puede ser modificado y que contiene un valor que nos será útil en un futuro para realizar un procedimiento específico

% o la introducción de instrucciones que esperan que el usuario actúe sobre el programa
%se selecciona por dónde continúa el flujo del programa cuando se cumple una o varias condiciones y hacer que las sentencias que ejecuta cada personaje sigan un orden temporal preestablecido de modo que interactúen entre sí;  

Como se aprecia en el diagrama~\ref{fig:total9_Snap}, si el total es 9 puntos, la sincronización alcanza un nivel intermedio, aumentando a la vez la cantidad de proyectos con un desarrollo avanzado en paralelismo y control de flujo. 

En la matriz ~\ref{fig:corr9_Snap} se constata que control de flujo presenta una elevada correlación directa con cada una de las siguientes: paralelismo, interactividad con el usuario y representación de los datos. 
Los programas codificados en base a una correcta secuenciación de pasos que pueden incluir bucles, demuestran nociones algorítmicas que facilitan dividir el problema en un conjunto de tareas que se realizan simultáneamente, que puedan ejecutarse cuando el usuario cambia el estado de un objeto y se modifiquen sus atributos o se empleen variables o listas como elemento abstracto para manejar los datos sobre los que operan estos programas. 

Abstracción es fuertemente interdependiente tanto con interactividad como con representación de los datos. Cuando el usuario controla el programa por teclado o por ratón se gestionan las acciones con clones, scripts o funciones propias, que emplean variables y listas para extraer patrones y generalizar a partir de scripts con una funcionalidad similar. Abstracción y sincronización son independientes entre sí. Existe una dependencia lineal moderada inversa entre control de flujo y condicionales y es aún más fuerte entre paralelismo y condicionales. 

Cuando el total asciende a los 10 puntos, tanto en sincronización como en control de flujo la moda se localiza en los 2 puntos. En paralelismo, los proyectos están más repartidos, siendo ligeramente superior la cantidad de proyectos con 3 puntos, como se atisba en el diagrama~\ref{fig:total10_Snap}.

\begin{figure}[H]
    \centering
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/distribucion_10_Snap}
        \caption{Diagrama de barras. Total=10}
        \label{fig:total10_Snap}
    \end{subfigure}       
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/corr_10_Snap}
        \caption{Matriz de correlación. Total=10}
        \label{fig:corr10_Snap}
    \end{subfigure}
    \caption{Distribución de puntuaciones asignadas y correlación entre dimensiones del PC cuando la puntuación total vale 10}
\end{figure}

En la figura~\ref{fig:corr10_Snap}, se comprueba la conservación de fuertes correlaciones directas entre representación de los datos e interactividad, entre ambas habilidades con abstracción, entre paralelismo y control de flujo y entre esta última con interactividad. Sincronización es independiente tanto de abstracción como de paralelismo. Establecer el orden en que se ejecutan los procesos mediante intercambio de mensajes o bloques de parada, no se ve influenciado por la modularidad presente en el código, ni porque estos módulos sean ejecutados a la vez por varios personajes cuando se reciben mensajes, o se producen eventos o condiciones. Las correlaciones negativas entre condicionales con control de flujo o con paralelismo son más intensas que en el caso anterior, sobre todo con esta última, que resulta perfecta. La ejecución simultánea de varios scripts, disminuye la ejecución de sentencias alternativas tras la evaluación de condiciones.

En el diagrama de barras~\ref{fig:total11_Snap} de se observa una sustancial mejora en condicionales. En paralelismo y en interactividad con el usuario la puntuación más frecuente es 2 puntos.

En la matriz de correlación~\ref{fig:corr11_Snap} se mantiene una fuerte dependencia lineal entre abstracción con interactividad y entre control de flujo con cada una de las siguientes: paralelismo, representación de los datos e interactividad con el usuario. Sin embargo la relación entre representación de los datos e interactividad con el usuario se modera. Control de flujo y sincronización están incorreladas, puesto que la estructura secuencial o iterativa seguida en los programas, no se relaciona con cómo interactúen entre sí para organizar su ejecución en el tiempo, ni entre interactividad con el usuario con condicionales, diferenciando entre los flujos de código que desencadenan su ejecución cuando ocurre un evento inducido por el usuario y aquellos sujetos a condiciones o cambios de estado provocados en el programa. Condicionales y paralelismo conservar una elevada interdependencia negativa.

\begin{figure}[H]
    \centering
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/distribucion_11_Snap}
        \caption{Diagrama de barras. Total=11}
        \label{fig:total11_Snap}
    \end{subfigure}       
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/corr_11_Snap}
        \caption{Matriz de correlación. Total=11}
        \label{fig:corr11_Snap}
    \end{subfigure}
    \caption{Distribución de puntuaciones asignadas y correlación entre dimensiones del PC cuando la puntuación total vale 11}
\end{figure}

\begin{figure}[H]
    \centering
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/distribucion_12_Snap}
        \caption{Diagrama de barras. Total=12}
        \label{fig:total12_Snap}
    \end{subfigure}       
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/corr_12_Snap}
        \caption{Matriz de correlación. Total=12}
        \label{fig:corr12_Snap}
    \end{subfigure}
    \caption{Distribución de puntuaciones asignadas y correlación entre dimensiones del PC cuando la puntuación total vale 12}
\end{figure}

Si se comparan las distribuciones~\ref{fig:total11_Snap} y~\ref{fig:total12_Snap}, la alteración más destacable es que se eleva la cantidad de proyectos con 2 puntos en interactividad con el usuario.

De nuevo control de flujo está fuertemente correlacionado con paralelismo, con datos y con interactividad con el usuario. Adicionalmente, la matriz~\ref{fig:corr12_Snap} refleja elevadas dependencias lineales entre abstracción y condicionales, de modo que al descomponer el problema en funciones y tareas concretas a realizar por varios personajes o clones, se incluyen en el código acciones diferentes a ejecutar dependiendo de la situación, y entre paralelismo y sincronización, de manera que si varios personajes llevan a cabo tareas simultáneas, se emplean mecanismos de coordinación que permiten que ocurran a la vez. Control de flujo y condicionales son independientes.
Si el programa se estructura secuencial o iterativamente, no tiene por qué incluir sentencias condicionales. Tampoco hay dependencia  entre sincronización y datos. Si distintos flujos de código son concurrentes, no tienen por qué modificarse los datos en variables, listas o atributos de los personajes. Se suaviza la correlación negativa entre paralelismo con condicionales.

%Expresar la solución como un conjunto ordenado de pasos y utilizar bucles no influye en el uso de condiciones.

En la distribución~\ref{fig:total13_Snap} correspondiente a un total de 13 puntos, representación de los datos incrementa su frecuencia en los 2 puntos.

En la matriz~\ref{fig:corr13_Snap} se refuerzan las correlaciones directas de la puntuación anterior, así como la dependencia positiva entre interactividad con el usuario y representación de los datos. No existe correlación entre paralelismo y abstracción. Cuando se aborda un problema complejo dividiéndolo en partes más sencillas de implementar y depurar, las funciones y scripts resultantes podrían ser ejecutadas por uno o varios personajes simultáneamente, pero en este caso, las variables que las definen son independientes linealmente. %%%

\begin{figure}[H]
    \centering
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/distribucion_13_Snap}
        \caption{Diagrama de barras. Total=13}
        \label{fig:total13_Snap}
    \end{subfigure}       
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/corr_13_Snap}
        \caption{Matriz de correlación. Total=13}
        \label{fig:corr13_Snap}
    \end{subfigure}
    \caption{Distribución de puntuaciones asignadas y correlación entre dimensiones del PC cuando la puntuación total vale 13}
\end{figure}

Según el diagrama~\ref{fig:total14_Snap}, crece la cantidad de proyectos que consiguen 2 puntos en abstracción, cuando el total se sitúa en 14 puntos.

Como se demuestra en la matriz~\ref{fig:corr14_Snap}, persisten las fuertes correlaciones positivas comentadas anteriormente. Además se obtiene una correlación casi perfecta entre control de flujo y sincronización. Si se ordenan instrucciones como una secuencia de pasos o se incluyen bucles que se repiten por siempre, un nº determinado de veces, o hasta que se cumpla una condición, aumenta la capacidad para organizar la ejecución de hilos y procesos para que interactúen entre sí. No existe dependencia lineal ni entre control de flujo con condicionales; ni entre paralelismo con condicionales, de modo que la ejecución simultánea de procesos no afecta a que se empleen estructuras selectivas; ni entre abstracción con sincronización o con paralelismo, por lo que si se descompone el problema en funciones o bloques propios encargados de tareas concretas, dando modularidad al código, o usando instancias de objetos, no dependerá de que los objetos se sincronicen para ejecutar sus scripts según un orden preestablecido o incluso simultáneamente.

%La capacidad para realizar programas que serán ejecutados simultáneamente por varios objetos al pulsar una tecla, la bandera verde o cuando se cumpla una condición, se empiece como clon, o se reciba un mensaje;

\begin{figure}[H]
    \centering
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/distribucion_14_Snap}
        \caption{Diagrama de barras. Total=14}
        \label{fig:total14_Snap}
    \end{subfigure}       
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/corr_14_Snap}
        \caption{Matriz de correlación. Total=14}
        \label{fig:corr14_Snap}
    \end{subfigure}
    \caption{Distribución de puntuaciones asignadas y correlación entre dimensiones del PC cuando la puntuación total vale 14}
\end{figure}

\begin{figure}[H]
    \centering
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/distribucion_15_Snap}
        \caption{Diagrama de barras. Total=15}
        \label{fig:total15_Snap}
    \end{subfigure}       
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/corr_15_Snap}
        \caption{Matriz de correlación. Total=15}
        \label{fig:corr15_Snap}
    \end{subfigure}
    \caption{Distribución de puntuaciones asignadas y correlación entre dimensiones del PC cuando la puntuación total vale 15}
\end{figure}

Como se observa en la distribución~\ref{fig:total15_Snap}, el paso al nivel avanzado está marcado por la asimilación completa de la sincronización y del control de flujo en la mayor parte de los proyectos.   

De hecho, ambas dimensiones presentan una dependencia lineal casi perfecta entre ellas y con paralelismo. Cuando se emplean estructuras de control iterativas, se utilizan mecanismos de parada, mensajes o espera condicionados a recibir una respuesta, a que se cumpla una condición o se produzca un evento para sincronizar los distintos flujos de código, algunos de los cuales pueden ejecutarse en paralelo.
Condicionales refuerza su dependencia con datos y con interactividad con el usuario, habilidades que a su vez están perfectamente correlacionadas. Al implementar las instrucciones alternativas que se seleccionan tras evaluar una situación usando 1, 2, o 3 de las estructuras condicionales presentes en Snap!: se modifican las variables y las listas y se incluyen sentencias que se ejecutarán en función de la acción realizada por el usuario al mover o pinchar con el ratón un objeto, dar una respuesta con el teclado, pulsar una tecla o utilizar el micrófono, sonidos o vídeo. Abstracción sigue correlacionada con condicionales, pero es independiente de sincronización, de control de flujo y de paralelismo, según la matriz~\ref{fig:corr15_Snap}.

\begin{figure}[H]
    \centering
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/distribucion_16_Snap}
        \caption{Diagrama de barras. Total=16}
        \label{fig:total16_Snap}
    \end{subfigure}       
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/corr_16_Snap}
        \caption{Matriz de correlación. Total=16}
        \label{fig:corr16_Snap}
    \end{subfigure}
    \caption{Distribución de puntuaciones asignadas y correlación entre dimensiones del PC cuando la puntuación total vale 16}
\end{figure}

Según la distribución~\ref{fig:total16_Snap}, las modas cuando el total alcanza los 16 puntos son: 2 puntos en condicionales, abstracción, interactividad con el usuario y representación de los datos y 3 puntos en sincronización, paralelismo y control de flujo.

La matriz~\ref{fig:corr16_Snap} refleja las mismas correlaciones perfectas, fuertes y nulas analizadas en la matriz~\ref{fig:corr15_Snap}. No obstante, hay capacidades cuyas dependencias no eran tan elevadas en la puntuación anterior, como las que se producen entre paralelismo con condicionales, de forma que si los objetos ejecutan varias secuencias de instrucciones al mismo tiempo, estas secuencias contendrán sentencias alternativas o condicionales. Otro par de correlaciones que se ven reforzadas son las que se dan entre abstracción con interactividad con el usuario o con representación de los datos, de manera que si se extrae lo relevante del problema a resolver y se descompone en programas, ya sean scripts o funciones propias, y/o se instancian personajes, se crean y actualizan las variables y listas que contienen los datos que se van obteniendo en los programas, y se controlan los distintos eventos que el usuario provoque al interactuar con el proyecto. En cambio, control de flujo sigue disminuyendo su interdependencia tanto con datos como con interactividad. % bajo un diseño top-down %=

\begin{figure}[H]
    \centering
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/distribucion_17_Snap}
        \caption{Diagrama de barras. Total=17}
        \label{fig:total17_Snap}
    \end{subfigure}       
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/corr_17_Snap}
        \caption{Matriz de correlación. Total=17}
        \label{fig:corr17_Snap}
    \end{subfigure}
    \caption{Distribución de puntuaciones asignadas y correlación entre dimensiones del PC cuando la puntuación total vale 17}
\end{figure}

En el diagrama~\ref{fig:total17_Snap} se perfilan las puntuaciones más frecuentes indicadas en la puntuación total anterior, aglutinando mayor proporción de proyectos para cada dimensión.

La matriz de correlación~\ref{fig:corr17_Snap} es muy similar a la conseguida con la calificación total de 16. Condicionales incrementa la correlación obtenida con cada una de las capacidades del pensamiento computacional. Condicionales con sincronización y condicionales con control de flujo, que en la puntuación anterior poseían correlaciones moderadas, ahora presentan correlaciones altas. Si se emplean estructuras selectivas que permiten decidir el flujo de código a ejecutar en función del estado, situación evaluada o condición, pudiendo incluir operadores lógicos en la evaluación de la condición, aumentan las nociones algorítmicas y los bucles que iteran hasta que se cumpla cierta condición, y se ajusta la ejecución de los distintos programas según un orden predeterminado basado en la comunicación entre los mismos, de modo que ciertos resultados obtenidos en otras partes del proyecto activen la ejecución del código. %=
%Al desarrollarse el pensamiento lógico asociado al uso de condicionales, el resto de capacidades también aumentan, presentando una fuerte dependencia con cada una de ellas. Las correlaciones entre condicionales con sincronización y con control de flujo pasan de moderadas a altas.

Es justamente condicionales la que consigue un máximo en 3, cuando la complejidad global se establece en 18 puntos, como se constata en la figura~\ref{fig:total17_Snap}. Se desarrolla por completo el pensamiento lógico que permite preveer y codificar las salidas alternativas resultantes de la comprobación de las premisas que se evalúan en el programa con if, if-else y operadores lógicos. % instrucciones condicionales compuestas

Además su correlación se hace prácticamente perfecta con sincronización, con paralelismo y con control de flujo. Cabe destacar que estas dimensiones presentan interdependencias perfectas, sentando las bases de la programación estructurada y la concurrencia. Por su parte, cada par conformado por abstracción, representación de los datos e interactividad con el usuario se relacionan linealmente de manera perfecta, como se indica en la matriz~\ref{fig:corr18_Snap}.

\begin{figure}[H]
    \centering
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/distribucion_18_Snap}
        \caption{Diagrama de barras. Total=18}
        \label{fig:total18_Snap}
    \end{subfigure}       
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/corr_18_Snap}
        \caption{Matriz de correlación. Total=18}
        \label{fig:corr18_Snap}
    \end{subfigure}
    \caption{Distribución de puntuaciones asignadas y correlación entre dimensiones del PC cuando la puntuación total vale 18}
\end{figure}

Las capacidades más difíciles de asimilar son interactividad, abstracción y representación de datos, como se infiere del diagrama~\ref{fig:total19_Snap}. Es complicado que un proyecto reúna todos los elementos considerados en abstracción y por ello se distribuye uniformemente entre los 2 y los 3 puntos. Las listas imperan sobre las variables, conformando estructuras de datos más complejas. 

Los coeficientes de correlación entre abstracción e interactividad con el usuario y entre esta última con representación de los datos son menores que las obtenidas en las puntuaciones totales anteriores. Sin embargo, son mucho más elevadas que las correlaciones que se obtienen entre interactividad con el usuario con el resto de dimensiones. No hay dependencia lineal entre las acciones que pueda realizar el usuario del programa, ya sea responder preguntas, mover objetos o personajes o insertar audio o vídeo, con emplear sentencias condicionales, ni con ordenar la ejecución de los distintos flujos de código de manera que interactúen entre sí, ni con el empleo de bucles, ni con la ejecución simultánea de varios scripts asociados a uno o varios objetos o personajes. Las correlaciones presentes entre abstracción y el resto de dimensiones son moderadas y las dependencias lineales entre representación de los datos con las demás capacidades son elevadas pero no perfectas.%=

\begin{figure}[H]
    \centering
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/distribucion_19_Snap}
        \caption{Diagrama de barras. Total=19}
        \label{fig:total19_Snap}
    \end{subfigure}       
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/corr_19_Snap}
        \caption{Matriz de correlación. Total=19}
        \label{fig:corr19_Snap}
    \end{subfigure}
    \caption{Distribución de puntuaciones asignadas y correlación entre dimensiones del PC cuando la puntuación total vale 19}
\end{figure}

Interactividad con el usuario será la última habilidad en adquirirse, como se deduce del diagrama~\ref{fig:total20_Snap}. Al mantenerse en 2 puntos para la mayoría de proyectos, sus coeficientes de correlación con el resto de variables son perfectos negativos. Implica que la gestión de los eventos que provoque el usuario sobre el programa, disminuye el desarrollo de otras capacidades. El resto de dimensiones guardan entre sí una correlación positiva perfecta.

\begin{figure}[H]
    \centering
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/distribucion_20_Snap}
        \caption{Diagrama de barras. Total=20}
        \label{fig:total20_Snap}
    \end{subfigure}       
    \begin{subfigure}[h]{.49\textwidth} 
        \includegraphics[width=\textwidth]{img/corr_20_Snap}
        \caption{Matriz de correlación. Total=20}
        \label{fig:corr20_Snap}
    \end{subfigure}
    \caption{Distribución de puntuaciones asignadas y correlación entre dimensiones del PC cuando la puntuación total vale 20}
\end{figure}

%Tampoco hay demasiados proyectos en los que el usuario introduzca audio o vídeo o se detecten colisiones entre objetos.
%NOTA: Incluir deducciones de las correlaciones y pie a la  sección siguiente

% Las situaciones a evaluar para elegir qué instrucciones se ejecutan, dependen de variables que almacenan el cambio de estado, del contenido de listas y de los eventos que provoca el usuario...
% No es solo alfabetización computacional per se.

%ADATOS: Análisis multivariante: con
%- resumir los datos con la mínima pérdida de información 
%-encontrar grupos en los datos si existen
%-clasificar nuevas observaciones en los grupos definidos.
%y relacionar dos conjuntos de variables, Entendimiento Grado de relación de 2 o más variables Gráfico de dispersión. Cuantificar o medir el grado de relación lineal entre dos variables, interdependencia, -1 1, invariante por transfomaciones lineales
% Encontrar patrones entre los datos para llevar a cabo unas acciones u otras. Recopilar datos y analizarlos de forma estadística
% Eventos: Acciones programadas para ese evento concreto. Un evento dispara la ejecución de las sentencias que penden de él
% El flujo de control en las ciencias computacionales se refiere al orden en el cual las declaraciones, instrucciones o llamadas de funciones de un programa imperativo o declarativo son ejecutadas o evaluadas. El flujo de objetos es lo mismo que el flujo de control, pero es mostrado como líneas rayadas en lugar de líneas sólidas. 
% comparar dos cosas = cotejar

% Una de las fortalezas del desarrollo del pensamiento computacional (Computer Science) es el desarrollo de la creatividad en la búsqueda continua de diferentes soluciones para un mismo problema. Quizás ésta simplificación o depuración, conseguir más con menos, ahorrar recursos o instrucciones, sea el mayor de los retos en el desarrollo del código de los programas.
% Proceso iterativo de mejra continua incrementando la complejidad


\begin{itemize}
    \item[•] ffff
\end{itemize}

\subsection{Análisis de clustering entre niveles o puntuaciones totales. Ruta de aprendizaje demostrada en los proyectos de Snap!}
\label{subsec:ruta_Snap}

% Cada clúster queda representado por el proyecto más cercano al centro o valor medio de los proyectos del grupo....

\begin{figure}[H]
	\centering
	\includegraphics[width=1.0\textwidth]{img/path_CT_Snap.png}
  	\caption{Ruta de aprendizaje de las dimensiones del PC en Snap!}\label{fig:path_Snap}
\end{figure}

    

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CONCLUSIONES %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Conclusiones}
\label{chap:conclusiones}


\section{Consecución de objetivos}
\label{sec:consecucion-objetivos}

Esta sección es la sección espejo de las dos primeras del capítulo de objetivos, donde se planteaba el objetivo general y se elaboraban los específicos.

Es aquí donde hay que debatir qué se ha conseguido y qué no. 
Cuando algo no se ha conseguido, se ha de justificar, en términos de qué problemas se han encontrado y qué medidas se han tomado para mitigar esos problemas.

Y si has llegado hasta aquí, siempre es bueno pasarle el corrector ortográfico, que las erratas quedan fatal en la memoria final.
Para eso, en Linux tenemos aspell, que se ejecuta de la siguiente manera desde la línea de \emph{shell}:

\begin{verbatim}
  aspell --lang=es_ES -c memoria.tex
\end{verbatim}

\section{Aplicación de lo aprendido}
\label{sec:aplicacion}

Aquí viene lo que has aprendido durante el Grado/Máster y que has aplicado en el TFG /TFM. 
Una buena idea es poner las asignaturas más relacionadas y comentar en un párrafo los conocimientos y habilidades puestos en práctica.

\begin{enumerate}
  \item a
  \item b
\end{enumerate}


\section{Lecciones aprendidas}
\label{sec:lecciones_aprendidas}

Aquí viene lo que has aprendido en el Trabajo Fin de Grado/Máster.

\begin{enumerate}
  \item Aquí viene uno.
  \item Aquí viene otro.
\end{enumerate}


\section{Trabajos futuros}
\label{sec:trabajos_futuros}

Ningún proyecto ni software se termina, así que aquí vienen ideas y funcionalidades que estaría bien tener implementadas en el futuro.

Es un apartado que sirve para dar ideas de cara a futuros TFGs/TFMs.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% APÉNDICE(S) %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\appendix
\chapter{Manual de usuario}
\label{app:manual}

Esto es un apéndice.
Si has creado una aplicación, siempre viene bien tener un manual de usuario.
Pues ponlo aquí.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BIBLIOGRAFIA %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage

% Las siguientes dos instrucciones es todo lo que necesitas
% para incluir las citas en la memoria
\bibliographystyle{abbrv}
\bibliography{memoria}  % memoria.bib es el nombre del fichero que contiene
% las referencias bibliográficas. Abre ese fichero y mira el formato que tiene,
% que se conoce como BibTeX. Hay muchos sitios que exportan referencias en
% formato BibTeX. Prueba a buscar en http://scholar.google.com por referencias
% y verás que lo puedes hacer de manera sencilla.
% Más información: 
% http://texblog.org/2014/04/22/using-google-scholar-to-download-bibtex-citations/

\end{document}
